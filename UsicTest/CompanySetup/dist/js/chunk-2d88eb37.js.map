{"version":3,"sources":["webpack:///./src/components/Modals/FaceCapture.vue?cdf7","webpack:///./src/views/Users/FaceCapture.vue?3d3b","webpack:///./src/views/Users/FaceCapture.vue?3ea4","webpack:///./src/views/Users/FaceCapture.vue","webpack:///./src/stores/faceStore.js","webpack:///./src/components/Modals/FaceCapture.vue","webpack:///src/components/Modals/FaceCapture.vue","webpack:///./src/components/Modals/FaceCapture.vue?13f1","webpack:///./src/components/Modals/FaceCapture.vue?2f88","webpack:///src/views/Users/FaceCapture.vue","webpack:///./src/views/Users/FaceCapture.vue?f89e","webpack:///./src/views/Users/FaceCapture.vue?1dc9","webpack:///./src/components/Modals/FaceCapture.vue?25e2","webpack:///./src/views/Users/FaceCapture.vue?2dc9","webpack:///./src/components/Modals/FaceCapture.vue?1085"],"names":["content","__esModule","default","module","i","locals","exports","add","render","_vm","this","_c","_self","staticClass","attrs","_v","_s","$t","on","handleClose","ref","detectAndCapture","handleCaptureError","staticRenderFns","useFaceStore","defineStore","state","API_BASE","faceDetectedCount","captureLimit","status","isCapturing","actions","setStatus","message","resetCapture","incrementCapture","directives","name","rawName","value","imageCaptured","expression","_uid","style","display","showFlash","isProcessing","_e","class","faceStatusClass","faceStatusText","lightingStatusClass","lightingStatusText","distanceStatusClass","distanceStatusText","stabilityIndicatorClass","stabilityText","emits","data","faceMesh","canvas","canvasCtx","tempCanvas","tempCanvasCtx","webcamElement","stream","stabilityCounter","STABILITY_THRESHOLD","autoCaptureEnabled","lightingQuality","faceDistance","hasFace","allConditionsGood","previousLandmarks","computed","progress","Math","round","canCapture","mounted","$nextTick","setTimeout","init","beforeUnmount","stopCamera","beforeDestroy","methods","_navigator$mediaDevic","$refs","webcam","canvasElement","Promise","resolve","Error","getContext","waitForMediaPipe","initializeFaceMesh","navigator","mediaDevices","getUserMedia","getCameraStream","srcObject","reject","timeout","onloadedmetadata","clearTimeout","forceVideoFit","onerror","err","processFrame","error","$emit","video","permissionError","code","userResponse","window","confirm","console","FaceMesh","document","readyState","loadMediaPipeScripts","attempts","maxAttempts","checkInterval","setInterval","_window$self","_window$mediapipe","FaceMeshAvailable","self","mediapipe","clearInterval","_window$self2","hasWindowFaceMesh","hasSelfFaceMesh","hasMediaPipe","windowKeys","Object","keys","filter","k","toLowerCase","includes","scripts","loaded","total","length","forEach","src","index","existing","querySelector","script","createElement","crossOrigin","onload","log","top","head","appendChild","FaceMeshClass","faceMeshInstance","locateFile","file","setOptions","maxNumFaces","refineLandmarks","minDetectionConfidence","minTrackingConfidence","onResults","onFaceMeshResults","bind","videoElement","HAVE_METADATA","requestAnimationFrame","width","videoWidth","height","videoHeight","drawImage","send","image","results","container","parentElement","containerWidth","clientWidth","containerHeight","clientHeight","save","clearRect","analyzeLightingConditions","multiFaceLandmarks","landmarks","isValidFaceLandmarks","analyzeFaceConditions","checkFaceStability","drawFaceBox","restore","videoAspect","containerAspect","videoDisplayWidth","videoDisplayHeight","videoOffsetX","videoOffsetY","scaleX","scaleY","leftEye","rightEye","noseTip","chin","leftEar","rightEar","minX","min","x","maxX","max","minY","y","maxY","faceCenterX","faceCenterY","faceWidth","faceHeight","faceCenterXContainer","faceCenterYContainer","faceWidthContainer","faceHeightContainer","boxColor","strokeStyle","lineWidth","setLineDash","beginPath","rect","stroke","keyPoints","point","eyeDistance","abs","imageData","tempCtx","imageDataObj","getImageData","totalBrightness","pixelCount","r","g","b","brightness","avgBrightness","faceSize","pointsInFrame","pointIndex","faceVisible","totalMovement","numLandmarks","dx","dy","sqrt","avgMovement","capturePhoto","dataUrl","toDataURL","imageBlob","manualCapture","getTracks","track","stop","videoEl","maxWidth","maxHeight","objectFit","position","left","component","components","FaceCapture","props","id","type","Number","required","String","isLoading","store","raw","JSON","stringify","companyId","GetUserInfo","CompanyId","myHeaders","Headers","append","checkResponse","fetch","method","headers","body","ok","checkResult","json","exists","deleteResponse","blob","Blob","startsWith","then","dataURLtoBlob","dataURL","header","base64","split","match","mime","binary","atob","len","u8arr","Uint8Array","charCodeAt","processImageData","uploadCapturedImages","popupMessage","ShowAlert","_this$GetUserInfo","checkNameExists","formData","FormData","File","response","result","_updateRes$data","updateRes","DataService","UserListingfaceupdate","userId","faceCapture","___CSS_LOADER_API_IMPORT___","push"],"mappings":"qGAGA,IAAIA,EAAU,EAAQ,QACnBA,EAAQC,aAAYD,EAAUA,EAAQE,SACnB,kBAAZF,IAAsBA,EAAU,CAAC,CAACG,EAAOC,EAAIJ,EAAS,MAC7DA,EAAQK,SAAQF,EAAOG,QAAUN,EAAQK,QAE5C,IAAIE,EAAM,EAAQ,QAAkEL,QACvEK,EAAI,WAAYP,GAAS,EAAM,CAAC,WAAY,EAAM,YAAa,K,oCCT5E,W,uBCGA,IAAIA,EAAU,EAAQ,QACnBA,EAAQC,aAAYD,EAAUA,EAAQE,SACnB,kBAAZF,IAAsBA,EAAU,CAAC,CAACG,EAAOC,EAAIJ,EAAS,MAC7DA,EAAQK,SAAQF,EAAOG,QAAUN,EAAQK,QAE5C,IAAIE,EAAM,EAAQ,QAAkEL,QACvEK,EAAI,WAAYP,GAAS,EAAM,CAAC,WAAY,EAAM,YAAa,K,kCCT5E,IAAIQ,EAAS,WAAkB,IAAIC,EAAIC,KAAKC,EAAGF,EAAIG,MAAMD,GAAG,OAAOA,EAAG,MAAM,CAACE,YAAY,aAAa,CAACF,EAAG,MAAM,CAACE,YAAY,iBAAiB,CAACF,EAAG,MAAM,CAACE,YAAY,mDAAmD,CAACF,EAAG,MAAM,CAACE,YAAY,iBAAiB,CAACF,EAAG,MAAM,CAACE,YAAY,yCAAyC,CAACF,EAAG,KAAK,CAACE,YAAY,wBAAwBC,MAAM,CAAC,KAAO,WAAW,CAACL,EAAIM,GAAG,IAAIN,EAAIO,GAAGP,EAAIQ,GAAG,qBAAqB,OAAON,EAAG,SAAS,CAACE,YAAY,QAAQK,GAAG,CAAC,MAAQT,EAAIU,cAAc,CAACR,EAAG,KAAK,CAACE,YAAY,cAAcC,MAAM,CAAC,cAAc,cAAcH,EAAG,MAAM,CAACG,MAAM,CAAC,GAAK,kBAAkBH,EAAG,cAAc,CAACS,IAAI,cAAcP,YAAY,uBAAuBK,GAAG,CAAC,iBAAiBT,EAAIY,iBAAiB,MAAQZ,EAAIa,uBAAuB,UAE3vBC,EAAkB,G,sICAf,MAAMC,EAAeC,eAAY,OAAQ,CAC9CC,MAAOA,KAAA,CACLC,SAAU,8BACVC,kBAAmB,EACnBC,aAAc,EACdC,OAAQ,aACRC,aAAa,IAGfC,QAAS,CACPC,UAAUC,GACRxB,KAAKoB,OAASI,GAGhBC,eACEzB,KAAKkB,kBAAoB,EACzBlB,KAAKoB,OAAS,aACdpB,KAAKqB,aAAc,GAGrBK,mBACE1B,KAAKkB,wB,gBCvBPpB,EAAS,WAAkB,IAAIC,EAAIC,KAAKC,EAAGF,EAAIG,MAAMD,GAAG,OAAOA,EAAG,MAAM,CAACE,YAAY,0BAA0B,CAACF,EAAG,MAAM,CAACE,YAAY,mBAAmB,CAACF,EAAG,QAAQ,CAAC0B,WAAW,CAAC,CAACC,KAAK,OAAOC,QAAQ,SAASC,OAAQ/B,EAAIgC,cAAeC,WAAW,mBAAmBtB,IAAI,SAASN,MAAM,CAAC,GAAM,UAASL,EAAIkC,KAAO,SAAW,GAAG,YAAc,MAAMhC,EAAG,SAAS,CAAC0B,WAAW,CAAC,CAACC,KAAK,OAAOC,QAAQ,SAASC,OAAQ/B,EAAIgC,cAAeC,WAAW,mBAAmBtB,IAAI,SAASN,MAAM,CAAC,GAAM,UAASL,EAAIkC,QAAUhC,EAAG,MAAM,CAACE,YAAY,gBAAgB+B,MAAO,CAAEC,QAASpC,EAAIqC,UAAY,QAAU,UAAarC,EAAIsC,aAAcpC,EAAG,MAAM,CAACE,YAAY,sBAAsB,CAACF,EAAG,MAAM,CAACE,YAAY,uBAAuBF,EAAG,IAAI,CAACF,EAAIM,GAAGN,EAAIO,GAAGP,EAAIQ,GAAG,0BAA0BR,EAAIuC,OAAOrC,EAAG,MAAM,CAACE,YAAY,gBAAgB,CAACF,EAAG,MAAM,CAACE,YAAY,eAAe,CAACF,EAAG,OAAO,CAACE,YAAY,gBAAgB,CAACJ,EAAIM,GAAGN,EAAIO,GAAGP,EAAIQ,GAAG,mBAAmB,OAAON,EAAG,OAAO,CAACE,YAAY,eAAeoC,MAAMxC,EAAIyC,iBAAiB,CAACzC,EAAIM,GAAGN,EAAIO,GAAGP,EAAI0C,qBAAqBxC,EAAG,MAAM,CAACE,YAAY,eAAe,CAACF,EAAG,OAAO,CAACE,YAAY,gBAAgB,CAACJ,EAAIM,GAAGN,EAAIO,GAAGP,EAAIQ,GAAG,uBAAuB,OAAON,EAAG,OAAO,CAACE,YAAY,eAAeoC,MAAMxC,EAAI2C,qBAAqB,CAAC3C,EAAIM,GAAGN,EAAIO,GAAGP,EAAI4C,yBAAyB1C,EAAG,MAAM,CAACE,YAAY,eAAe,CAACF,EAAG,OAAO,CAACE,YAAY,gBAAgB,CAACJ,EAAIM,GAAGN,EAAIO,GAAGP,EAAIQ,GAAG,aAAa,OAAON,EAAG,OAAO,CAACE,YAAY,eAAeoC,MAAMxC,EAAI6C,qBAAqB,CAAC7C,EAAIM,GAAGN,EAAIO,GAAGP,EAAI8C,2BAA2B5C,EAAG,MAAM,CAACE,YAAY,YAAY,CAACF,EAAG,MAAM,CAACE,YAAY,uBAAuB,CAACF,EAAG,MAAM,CAACE,YAAY,gBAAgBoC,MAAMxC,EAAI+C,0BAA0B7C,EAAG,OAAO,CAACF,EAAIM,GAAGN,EAAIO,GAAGP,EAAIgD,yBAExqDlC,EAAkB,GC4CP,G,UAAA,CACfe,KAAA,cACAoB,MAAA,2BACAC,OACA,OACAC,SAAA,KACAC,OAAA,KACAC,UAAA,KACAC,WAAA,KACAC,cAAA,KACAC,cAAA,KACAC,OAAA,KACAC,iBAAA,EACApC,aAAA,EACAqC,oBAAA,GACAtB,WAAA,EACAuB,oBAAA,EACA5B,eAAA,EACAM,cAAA,EAGAuB,gBAAA,EACAC,aAAA,EACAC,SAAA,EACAC,mBAAA,EACAC,kBAAA,OAGAC,SAAA,CACAxB,iBACA,YAAAqB,QAAA,KAAAvD,GAAA,sBAAAA,GAAA,cAEAiC,kBACA,YAAAsB,QAAA,8BAEAnB,qBACA,YAAAiB,gBAAA,QAAArD,GAAA,QACA,KAAAqD,gBAAA,QAAArD,GAAA,YACA,KAAAA,GAAA,SAEAmC,sBACA,YAAAkB,gBAAA,iBACA,KAAAA,gBAAA,oBACA,gBAEAf,qBACA,YAAAgB,aAAA,SAAAtD,GAAA,YACA,KAAAsD,aAAA,QAAAtD,GAAA,eACA,KAAAA,GAAA,SAEAqC,sBACA,YAAAiB,aAAA,UAAAA,aAAA,kBACA,eAEAf,0BACA,YAAAW,kBAAA,KAAAC,oBAAA,SACA,KAAAD,iBAAA,aACA,IAEAV,gBACA,QAAAU,kBAAA,KAAAC,oBAAA,YAAAnD,GAAA,oBACA,SAAAwD,kBAAA,YAAAxD,GAAA,mBACA,QAAAkD,iBAAA,GACA,MAAAS,EAAAC,KAAAC,MAAA,KAAAX,iBAAA,KAAAC,oBAAA,KACA,cAAAnD,GAAA,mBAAA2D,KAEA,YAAA3D,GAAA,yBAEA8D,aACA,YAAAZ,kBAAA,KAAAC,sBAAA,KAAArC,cAAA,KAAAU,gBAGAuC,UAEA,KAAAC,UAAA,KACAC,WAAA,SAAAC,OAAA,QAGAC,gBACA,KAAAC,cAEAC,gBACA,KAAAD,cAEAE,QAAA,CACA,aACA,QAAAC,QACA,KAAAP,YAEA,IAAAhB,EAAA,KAAAwB,MAAAC,OACAC,EAAA,KAAAF,MAAA5B,OAGA,KAAAI,IAAA0B,WACA,IAAAC,QAAAC,GAAAX,WAAAW,EAAA,MACA5B,EAAA,KAAAwB,MAAAC,OACAC,EAAA,KAAAF,MAAA5B,QAEAI,IAAA0B,GACA,UAAAG,MAAA,KAAA7E,GAAA,8BAUA,GANA,KAAAgD,gBACA,KAAAJ,OAAA8B,EACA,KAAA7B,UAAA,KAAAD,OAAAkC,WAAA,YAGA,KAAAC,oBACA,KAAAC,qBACA,UAAAH,MAAA,KAAA7E,GAAA,mCAIA,WAAAuE,EAAAU,UAAAC,oBAAA,IAAAX,MAAAY,aACA,UAAAN,MAAA,KAAA7E,GAAA,yBAIA,MAAAiD,QAAA,KAAAmC,kBAEA,KAAAnC,SACA,KAAAD,cAAAqC,UAAApC,QAGA,IAAA0B,QAAA,CAAAC,EAAAU,KACA,MAAAC,EAAAtB,WAAA,IAAAqB,EAAA,IAAAT,MAAA,KAAA7E,GAAA,wBAEA,KAAAgD,cAAAwC,iBAAA,KACAC,aAAAF,GACA,KAAAG,gBACAd,KAGA,KAAA5B,cAAA2C,QAAAC,IACAH,aAAAF,GACAD,EAAAM,MAIA,KAAAF,gBACA,KAAAG,eACA,MAAAC,GACA,KAAAC,MAAA,QAAAD,KAKA,wBACA,IAEA,MAAA7C,QAAAgC,UAAAC,aAAAC,aAAA,CAAAa,OAAA,IAEA,OAAA/C,EACA,MAAA6C,GACA,uBAAAA,EAAAzE,MAAA,kBAAAyE,EAAAzE,KAWA,MADA,KAAA0E,MAAA,QAAAD,GACAA,EAXA,CAEA,MAAAG,EAAA,IAAApB,MAAA,KAAA7E,GAAA,6BACAiG,EAAAC,KAAA,oBACA,KAAAH,MAAA,QAAAE,MAaA,kCACA,IAEA,MAAAE,EAAAC,OAAAC,QAAA,KAAArG,GAAA,4BAEA,IAAAmG,EAKA,UAAAtB,MAAA,KAAA7E,GAAA,qCAHA,KAAAoF,kBAKA,MAAAU,GAEAQ,QAAAR,MAAA,qCAAAA,GACA,KAAAC,MAAA,QAAAD,KAIA,yBAEA,IAAAM,OAAAG,iBAKA,IAAA5B,QAAAC,GAAAX,WAAAW,EAAA,OAGAwB,OAAAG,UAUA,OALAH,OAAAG,UAAA,aAAAC,SAAAC,kBACA,KAAAC,uBAIA,IAAA/B,QAAA,CAAAC,EAAAU,KACA,IAAAqB,EAAA,EACA,MAAAC,EAAA,IAEAC,EAAAC,YAAA,SAAAC,EAAAC,EACAL,IAGA,MAAAM,EACAb,OAAAG,WACA,QADAQ,EACAX,OAAAc,YAAA,IAAAH,OAAA,EAAAA,EAAAR,YACA,qBAAAA,kBAAA,QACA,QADAS,EACAZ,OAAAe,iBAAA,IAAAH,OAAA,EAAAA,EAAAT,UAEA,GAAAU,GACAb,OAAAG,UAAAU,IACAb,OAAAG,SAAAU,GAEAG,cAAAP,GACAjC,SACA,GAAA+B,GAAAC,EAAA,KAAAS,EACAD,cAAAP,GACAP,QAAAR,MAAA,0CACAwB,oBAAAlB,OAAAG,SACAgB,kBAAA,QAAAF,EAAAjB,OAAAc,YAAA,IAAAG,MAAAd,UACAiB,eAAApB,OAAAe,UACAM,WAAAC,OAAAC,KAAAvB,QAAAwB,OAAAC,GACAA,EAAAC,cAAAC,SAAA,SACAF,EAAAC,cAAAC,SAAA,SACAF,EAAAC,cAAAC,SAAA,gBAGAzC,EAAA,IAAAT,MAAA,KAAA7E,GAAA,8BAEA,QAIA0G,uBACA,WAAA/B,QAAA,CAAAC,EAAAU,KACA,MAAA0C,EAAA,CACA,2EACA,6EACA,6EACA,sEAGA,IAAAC,EAAA,EACA,MAAAC,EAAAF,EAAAG,OAEAH,EAAAI,QAAA,CAAAC,EAAAC,KAEA,MAAAC,EAAA/B,SAAAgC,cAAA,eAAAH,OACA,GAAAE,EAGA,OAFAN,SACAA,IAAAC,GAAAtD,KAIA,MAAA6D,EAAAjC,SAAAkC,cAAA,UACAD,EAAAJ,MACAI,EAAAE,YAAA,YACAF,EAAAG,OAAA,KACAX,IACA3B,QAAAuC,IAAA,iBAAAP,EAAA,KAAAJ,MAAAG,KACAJ,IAAAC,GACAtD,KAGA6D,EAAA9C,QAAA,KACAL,EAAA,IAAAT,MAAA,oCAAAwD,KAEAjC,OAAA0C,IAAAtC,SAAAuC,KAAAC,YAAAP,QAKAzD,qBACA,MAAAiE,EACA7C,OAAAG,UACAH,OAAAlH,QAAAkH,OAAAlH,OAAAqH,SAEA,IAAA0C,GAAA,oBAAAA,EACA,SAGA,IACA,MAAAC,EAAA,IAAAD,EAAA,CACAE,WAAAC,GACA,qDAAAA,IAaA,OATAF,EAAAG,WAAA,CACAC,YAAA,EACAC,iBAAA,EACAC,uBAAA,GACAC,sBAAA,KAGAP,EAAAQ,UAAA,KAAAC,kBAAAC,KAAA,OACA,KAAAjH,SAAAuG,GACA,EACA,MAAApD,GACA,WAIA,qBAEA,QAAAtE,cAAA,OAEA,SAAAyB,SAAA,KAAAD,cAAA,OAEA,MAAA6G,EAAA,KAAArF,MAAAC,OACA,GAAAoF,EAGA,GAAAA,EAAApD,WAAAoD,EAAAC,cACAC,sBAAA,SAAAlE,oBADA,CAMA,QAAAlD,SACA,IAEA,KAAAG,aACA,KAAAA,WAAA0D,SAAAkC,cAAA,UACA,KAAA3F,cAAA,KAAAD,WAAAgC,WAAA,OAKA,KAAAhC,WAAAkH,QAAAH,EAAAI,YACA,KAAAnH,WAAAoH,SAAAL,EAAAM,cAEA,KAAArH,WAAAkH,MAAAH,EAAAI,WACA,KAAAnH,WAAAoH,OAAAL,EAAAM,aAIA,KAAApH,cAAAqH,UACAP,EACA,EACA,EACA,KAAA/G,WAAAkH,MACA,KAAAlH,WAAAoH,cAIA,KAAAvH,SAAA0H,KAAA,CAAAC,MAAA,KAAAxH,aACA,MAAAgD,SAOA,KAAAlD,QACA,KAAAC,WACAgH,EAAAI,WAAA,GACAJ,EAAAM,YAAA,IAGA,KAAAvH,OAAAoH,QAAAH,EAAAI,YACA,KAAArH,OAAAsH,SAAAL,EAAAM,cAEA,KAAAvH,OAAAoH,MAAAH,EAAAI,WACA,KAAArH,OAAAsH,OAAAL,EAAAM,aAEA,KAAAtH,UAAAuH,UAAAP,EAAA,SAAAjH,OAAAoH,MAAA,KAAApH,OAAAsH,SAIAH,sBAAA,SAAAlE,kBAGA8D,kBAAAY,GAEA,QAAA/I,cAAA,OAEA,SAAAoB,SAAA,KAAAC,UAAA,OAGA,MAAAgH,EAAA,KAAArF,MAAAC,OACA,IAAAoF,EAAA,OAGA,MAAAW,EAAAX,EAAAY,cACA,IAAAD,EAAA,OAEA,MAAAE,EAAAF,EAAAG,YACAC,EAAAJ,EAAAK,aAiBA,GAdA,KAAAjI,OAAAoH,QAAAU,GACA,KAAA9H,OAAAsH,SAAAU,IACA,KAAAhI,OAAAoH,MAAAU,EACA,KAAA9H,OAAAsH,OAAAU,GAIA,KAAA/H,UAAAiI,OACA,KAAAjI,UAAAkI,UAAA,SAAAnI,OAAAoH,MAAA,KAAApH,OAAAsH,QAGA,KAAAc,0BAAAT,EAAAD,OAGAC,EAAAU,oBAAAV,EAAAU,mBAAA9C,OAAA,SAAArH,YAAA,CAEA,MAAAoK,EAAAX,EAAAU,mBAAA,GAGA,KAAAE,qBAAAD,IACA,KAAA3H,SAAA,EAEA,KAAA6H,sBAAAF,GACA,KAAAG,mBAAAH,GAGA,KAAAI,YAAAJ,KAGA,KAAA3H,SAAA,EACA,KAAAL,iBAAA,QAGA,KAAAK,SAAA,EACA,KAAAL,iBAAA,EAGA,KAAAL,UAAA0I,WAGAD,YAAAJ,GACA,SAAAtI,SAAA,KAAAC,YAAA,KAAAU,QAAA,OAEA,IAAA2H,KAAA/C,OAAA,WAGA,MAAA0B,EAAA,KAAArF,MAAAC,OACA,IAAAoF,MAAAI,WAAA,OAEA,MAAAO,EAAAX,EAAAY,cACA,IAAAD,EAAA,OAEA,MAAAE,EAAAF,EAAAG,YACAC,EAAAJ,EAAAK,aAGAW,EAAA3B,EAAAI,WAAAJ,EAAAM,YACAsB,EAAAf,EAAAE,EAEA,IAAAc,EAAAC,EAAAC,EAAAC,EAEAL,EAAAC,GAEAC,EAAAhB,EACAiB,EAAAjB,EAAAc,EACAI,EAAA,EACAC,GAAAjB,EAAAe,GAAA,IAGAA,EAAAf,EACAc,EAAAd,EAAAY,EACAI,GAAAlB,EAAAgB,GAAA,EACAG,EAAA,GAIA,MAAAC,EAAAJ,EAAA7B,EAAAI,WACA8B,EAAAJ,EAAA9B,EAAAM,YAMA6B,GAJA,KAAApJ,OAAAoH,MACA,KAAApH,OAAAsH,OAGAgB,EAAA,KACAe,EAAAf,EAAA,KACAgB,EAAAhB,EAAA,GACAiB,EAAAjB,EAAA,KACAkB,EAAAlB,EAAA,KACAmB,EAAAnB,EAAA,KAGA,IAAAc,IAAAC,IAAAC,IAAAC,IAAAC,IAAAC,EACA,OAIA,MAAAC,EAAA1I,KAAA2I,IAAAH,EAAAI,EAAAH,EAAAG,EAAAR,EAAAQ,EAAAP,EAAAO,GACAC,EAAA7I,KAAA8I,IAAAN,EAAAI,EAAAH,EAAAG,EAAAR,EAAAQ,EAAAP,EAAAO,GACAG,EAAA/I,KAAA2I,IAAAP,EAAAY,EAAAX,EAAAW,EAAAV,EAAAU,GACAC,EAAAjJ,KAAA8I,IAAAP,EAAAS,EAAAV,EAAAU,GAEAE,GAAAR,EAAAG,GAAA,EACAM,GAAAJ,EAAAE,GAAA,EACAG,EAAA,KAAAP,EAAAH,GACAW,EAAA,GAAAJ,EAAAF,GAGAO,EAAAtB,EAAAkB,EAAAjD,EAAAI,WAAA6B,EACAqB,EAAAtB,EAAAkB,EAAAlD,EAAAM,YAAA4B,EACAqB,EAAAJ,EAAAnD,EAAAI,WAAA6B,EACAuB,EAAAJ,EAAApD,EAAAM,YAAA4B,EAGA,GAAAiB,GAAA,GAAAC,GAAA,GACAD,EAAA,GAAAC,EAAA,EACA,OAIA,IAAAK,EAAA,UAqBA,GApBA,KAAA9J,kBACA8J,EAAA,UACA,KAAA/J,UACA+J,EAAA,WAIA,KAAAzK,UAAA0K,YAAAD,EACA,KAAAzK,UAAA2K,UAAA,EACA,KAAA3K,UAAA4K,YAAA,IAEA,KAAA5K,UAAA6K,YACA,KAAA7K,UAAA8K,KACAT,EAAAE,EAAA,EACAD,EAAAE,EAAA,EACAD,EACAC,GAEA,KAAAxK,UAAA+K,SAEA,KAAApK,mBAAA,KAAAN,iBAAA,GACA,MAAAS,EAAA,KAAAT,iBAAA,KAAAC,oBACA,KAAAN,UAAA0K,YAAA,UACA,KAAA1K,UAAA2K,UAAA,EACA,KAAA3K,UAAA6K,YACA,KAAA7K,UAAA8K,KACAT,EAAAE,EAAA,EACAD,EAAAE,EAAA,EACAD,EAAAzJ,EACA0J,GAEA,KAAAxK,UAAA+K,WAIAzC,qBAAAD,GACA,IAAAA,KAAA/C,OAAA,IACA,SAIA,MAAA0F,EAAA,uBAEA,UAAAvF,KAAAuF,EAAA,CACA,MAAAC,EAAA5C,EAAA5C,GACA,IAAAwF,GACA,kBAAAA,EAAAtB,GACA,kBAAAsB,EAAAlB,GACAkB,EAAAtB,EAAA,GAAAsB,EAAAtB,EAAA,GACAsB,EAAAlB,EAAA,GAAAkB,EAAAlB,EAAA,EACA,SAKA,MAAAZ,EAAAd,EAAA,IACAe,EAAAf,EAAA,KACAgB,EAAAhB,EAAA,GACAiB,EAAAjB,EAAA,KAEA6C,EAAAnK,KAAAoK,IAAA/B,EAAAO,EAAAR,EAAAQ,GACAS,EAAArJ,KAAAoK,IAAA7B,EAAAS,EAAAV,EAAAU,GAGA,GAAAmB,EAAA,KAAAd,EAAA,IACA,SAIA,GAAAc,EAAA,IAAAd,EAAA,GACA,SAIA,MAAAH,GAAAd,EAAAQ,EAAAP,EAAAO,GAAA,EACAO,GAAAb,EAAAU,EAAAT,EAAAS,GAAA,EAGA,QAAAE,GAAA,IAAAA,EAAA,KACAC,GAAA,IAAAA,EAAA,MAOA/B,0BAAAiD,GACA,MAAAnL,EAAA0D,SAAAkC,cAAA,UACAwF,EAAApL,EAAAgC,WAAA,MACAhC,EAAAkH,MAAA,IACAlH,EAAAoH,OAAA,IACAgE,EAAA9D,UAAA6D,EAAA,aAEA,MAAAE,EAAAD,EAAAE,aAAA,aACA1L,EAAAyL,EAAAzL,KAEA,IAAA2L,EAAA,EACAC,EAAA,EAEA,QAAAnP,EAAA,EAAAA,EAAAuD,EAAAyF,OAAAhJ,GAAA,GACA,MAAAoP,EAAA7L,EAAAvD,GACAqP,EAAA9L,EAAAvD,EAAA,GACAsP,EAAA/L,EAAAvD,EAAA,GACAuP,GAAAH,EAAAC,EAAAC,GAAA,EACAJ,GAAAK,EACAJ,IAGA,MAAAK,EAAAN,EAAAC,EACA,KAAAjL,gBAAAsL,EAAA,KAGAvD,sBAAAF,GACA,IAAAA,KAAA/C,OAAA,IAGA,OAFA,KAAA5E,SAAA,OACA,KAAAC,mBAAA,GAIA,MAAAwI,EAAAd,EAAA,IACAe,EAAAf,EAAA,KACAgB,EAAAhB,EAAA,GACAiB,EAAAjB,EAAA,KAGA,IAAAc,IAAAC,IAAAC,IAAAC,EAGA,OAFA,KAAA5I,SAAA,OACA,KAAAC,mBAAA,GAIA,MAAAuK,EAAAnK,KAAAoK,IAAA/B,EAAAO,EAAAR,EAAAQ,GAAA,KAAA5J,OAAAoH,MACAiD,EAAArJ,KAAAoK,IAAA7B,EAAAS,EAAAV,EAAAU,GAAA,KAAAhK,OAAAsH,OACA0E,GAAAb,EAAAd,GAAA,EAGA,GAAA2B,EAAA,IAAAA,EAAA,IAIA,OAFA,KAAArL,SAAA,OACA,KAAAC,mBAAA,GAKA,KAAAF,aADAsL,EAAA,IACA,GACAA,EAAA,IACA,IAEA,IAAAA,EAAA,SAIA,MAAAf,EAAA,uBACA,IAAAgB,EAAA,EACA,UAAAC,KAAAjB,EAAA,CACA,MAAAC,EAAA5C,EAAA4D,GACAhB,KAAAtB,GAAA,KAAAsB,EAAAtB,GAAA,KACAsB,EAAAlB,GAAA,KAAAkB,EAAAlB,GAAA,KACAiC,IAKA,MAAAE,EAAAF,GAAA,EAEA,KAAArL,kBAAA,KAAAH,gBAAA,IACA,KAAAC,cAAA,SAAAA,cAAA,KACA,KAAAC,SAAAwL,GAGA1D,mBAAAH,GACA,SAAAzH,mBAAA,KAAA3C,YAEA,YADA,KAAA2C,kBAAAyH,GAIA,SAAA1H,kBAGA,OAFA,KAAAN,iBAAA,OACA,KAAAO,kBAAAyH,GAIA,IAAA8D,EAAA,EACA,MAAAC,EAAArL,KAAA2I,IAAArB,EAAA/C,OAAA,KAAA1E,kBAAA0E,OAAA,IAEA,QAAAhJ,EAAA,EAAAA,EAAA8P,EAAA9P,IAAA,CACA,MAAA+P,EAAAhE,EAAA/L,GAAAqN,EAAA,KAAA/I,kBAAAtE,GAAAqN,EACA2C,EAAAjE,EAAA/L,GAAAyN,EAAA,KAAAnJ,kBAAAtE,GAAAyN,EACAoC,GAAApL,KAAAwL,KAAAF,IAAAC,KAGA,MAAAE,EAAAL,EAAAC,EAGA,KAAA/L,iBADAmM,EAAA,KACAzL,KAAA2I,IAAA,KAAArJ,iBAAA,OAAAC,qBAEAS,KAAA8I,IAAA,KAAAxJ,iBAAA,KAIA,KAAAA,kBAAA,KAAAC,qBACA,KAAAC,qBACA,KAAAtC,cACA,KAAAU,eACA,KAAA8N,eAGA,KAAA7L,kBAAAyH,GAGAoE,eACA,QAAAxO,cAAA,KAAA0C,mBAAA,KAAAhC,cAAA,OAEA,KAAAV,aAAA,EACA,KAAAU,eAAA,EACA,KAAA4B,oBAAA,EAEA,KAAAvB,WAAA,EACAoC,WAAA,KACA,KAAApC,WAAA,GACA,KAEA,MAAAgI,EAAA,KAAArF,MAAAC,OACA,IAAAoF,EAAA,OAGA,MAAA/G,EAAA0D,SAAAkC,cAAA,UACA5F,EAAAkH,MAAAH,EAAAI,WACAnH,EAAAoH,OAAAL,EAAAM,YACA,MAAA+D,EAAApL,EAAAgC,WAAA,MAEAoJ,EAAA9D,UAAAP,EAAA,IAAA/G,EAAAkH,MAAAlH,EAAAoH,QAEA,MAAAqF,EAAAzM,EAAA0M,UAAA,iBAGA,KAAApL,aAGA,KAAAtC,cAAA,EACA,KAAAiE,MAAA,kBACAkI,UAAAsB,EACAE,UAAA,QAKAvO,eACA,KAAAM,eAAA,EACA,KAAAV,aAAA,EACA,KAAAgB,cAAA,EACA,KAAAoB,iBAAA,EACA,KAAAE,oBAAA,GAGAsM,gBACA,KAAA5O,cAAA,KAAA0C,mBAAA,KAAAhC,eACA,KAAA8N,gBAIAlL,aACA,KAAAnB,SACA,KAAAA,OAAA0M,YAAAvH,QAAAwH,KAAAC,QACA,KAAA5M,OAAA,MAEA,KAAAD,gBACA,KAAAA,cAAAqC,UAAA,OAIAK,gBACA,MAAAoK,EAAA,KAAAtL,MAAAC,OACA,IAAAqL,EAAA,OAEA,MAAAtF,EAAAsF,EAAArF,cACAD,IAGAsF,EAAAnO,MAAAqI,MAAAQ,EAAAG,YAAA,KACAmF,EAAAnO,MAAAuI,OAAAM,EAAAK,aAAA,KACAiF,EAAAnO,MAAAoO,SAAA,OACAD,EAAAnO,MAAAqO,UAAA,OACAF,EAAAnO,MAAAsO,UAAA,UACAH,EAAAnO,MAAAuO,SAAA,WACAJ,EAAAnO,MAAAmH,IAAA,IACAgH,EAAAnO,MAAAwO,KAAA,SC31BmW,I,wBCQ/VC,EAAY,eACd,EACA,EACA,GACA,EACA,KACA,WACA,MAIa,EAAAA,E,QCgBA,GACfC,WAAA,CACAC,eAEAC,MAAA,CACAC,GAAA,CACAC,KAAAC,OACAC,UAAA,GAEAtP,KAAA,CACAoP,KAAAG,OACAD,UAAA,IAGAjO,OACA,OACAmO,WAAA,IAIAnN,SAAA,CACAoN,QACA,OAAAvQ,MAGAwD,UACA,KAAA+M,MAAA5P,gBAEAoD,QAAA,CACA,sBAAAkM,GACA,IACA,MAAAO,EAAAC,KAAAC,UAAA,CACAC,UAAAN,OAAA,KAAAO,YAAAC,WACAZ,GAAAI,OAAAJ,KAGAa,EAAA,IAAAC,QACAD,EAAAE,OAAA,mCAEA,MAAAC,QAAAC,MAAA,KAAAX,MAAApQ,SAAA,eACAgR,OAAA,OACAC,QAAAN,EACAO,KAAAb,IAEA,IAAAS,EAAAK,GACA,SAEA,MAAAC,QAAAN,EAAAO,OAEA,GAAAD,EAAAE,OAAA,CACA,MAAAC,QAAAR,MAAA,KAAAX,MAAApQ,SAAA,gBACAgR,OAAA,OACAC,QAAAN,EACAO,KAAAb,IAEA,IAAAkB,EAAAJ,GACA,eAEAI,EAAAF,OACA,SAEA,SAEA,MAAAjM,GACA,WAGA,uBAAApD,GACA,IAAAwP,EACA,GAAAxP,EAAAuL,qBAAAkE,KAEAD,EAAAxP,EAAAuL,eAEA,qBAAAvL,EAAAuL,WAAAvL,EAAAuL,UAAAmE,WAAA,SAEAF,QAAAT,MAAA/O,EAAAuL,WAAAoE,KAAA9D,KAAA2D,YAEA,sBAAAxP,EAAAuL,YAAAvL,EAAAuL,UAAAmE,WAAA,cAKA,UAAAvN,MAAA,KAAA7E,GAAA,kCAHAkS,EAAA,KAAAI,cAAA5P,EAAAuL,WAKA,IAAAiE,EAAA,UAAArN,MAAA,KAAA7E,GAAA,2BACA,OAAAkS,GAGAI,cAAAC,GACA,IAAAA,MAAAxK,SAAA,KAEA,YAGA,MAAAyK,EAAAC,GAAAF,EAAAG,MAAA,KACAC,EAAAH,EAAAG,MAAA,WAEA,IAAAA,EAEA,YAGA,MAAAC,EAAAD,EAAA,GACAE,EAAAC,KAAAL,GACAM,EAAAF,EAAA1K,OACA6K,EAAA,IAAAC,WAAAF,GAEA,QAAA5T,EAAA,EAAAA,EAAA4T,EAAA5T,IACA6T,EAAA7T,GAAA0T,EAAAK,WAAA/T,GAGA,WAAAgT,KAAA,CAAAa,GAAA,CAAAvC,KAAAmC,KAKA,uBAAAlQ,GAEA,MAAAwP,QAAA,KAAAiB,iBAAAzQ,SACA,KAAA0Q,qBAAAlB,IAEA7R,mBAAAyF,GACA,MAAAuN,EAAA,OAAAvN,EAAA7E,SAAA,KAAAjB,GAAA,2BACA,KAAAsT,UAAAD,EAAA,kBAAArT,GAAA,UACA,KAAAE,eAEA,2BAAAuP,GACA,QAAA8D,EACA,KAAA1C,WAAA,QAsBA,KAAA2C,gBAAA,KAAAhD,IAEA,MAAAiD,EAAA,IAAAC,SACAD,EAAAlC,OAAA,KAAAX,OAAA,KAAAJ,IAAA,KACAiD,EAAAlC,OAAA,OAAAX,OAAA,KAAAvP,MAAA,KACAoS,EAAAlC,OAAA,YAAAX,QAAA,QAAA2C,EAAA,KAAApC,mBAAA,IAAAoC,OAAA,EAAAA,EAAAnC,YAAA,KACAqC,EAAAlC,OAAA,WAAAoC,KAAA,CAAAlE,GAAA,eAAAgB,KAAA,gBAIA,MAAAmD,QAAAnC,MAAA,KAAAX,MAAApQ,SAAA,WACAgR,OAAA,OACAE,KAAA6B,IAGAI,QAAAD,EAAA7B,OACA,eAAA8B,EAAAhT,OAAA,KAAAiT,EAEA,MAAAC,QAAAC,OAAAC,sBAAA,CACApT,OAAA,EACAqT,OAAA,KAAA1D,KAEA,iBAAAuD,QAAA,IAAAA,OAAA,EAAAA,EAAAlT,SAAA,mBAAAkT,QAAA,IAAAA,GAAA,QAAAD,EAAAC,EAAArR,YAAA,IAAAoR,OAAA,EAAAA,EAAAjT,QAEA,KAAAkF,MAAA,gBAAAmO,OAAA,KAAA1D,GAAA3P,OAAA,IACA,KAAAyS,UAAA,KAAAtT,GAAA,+CAAAA,GAAA,cACA,CACA,MAAA+Q,EAAAC,KAAAC,UAAA,CACAC,UAAAN,OAAA,KAAAO,YAAAC,WACAZ,GAAAI,OAAA,KAAAJ,MAGAa,EAAA,IAAAC,QACAD,EAAAE,OAAA,mCACA,MAAAU,QAAAR,MAAA,KAAAX,MAAApQ,SAAA,gBACAgR,OAAA,OACAC,QAAAN,EACAO,KAAAb,IAGA,IAAAkB,EAAAJ,GACA,eAMA,KAAAyB,UAAAO,EAAA5S,SAAA,KAAAjB,GAAA,8CAAAA,GAAA,UAGA,MAAA4F,GACA,KAAA0N,UAAA,KAAAtT,GAAA,mCAAAA,GAAA,UACA,QACA,KAAA6Q,WAAA,EACA,KAAA3Q,cACA,KAAAsE,MAAA2P,aAAA,KAAA3P,MAAA2P,YAAAjT,iBAKAhB,cACA,KAAA4Q,MAAA5P,eACA,KAAA6E,MAAA,WAKA1B,mBC5PmW,ICQ/V,G,UAAY,eACd,EACA9E,EACAe,GACA,EACA,KACA,WACA,OAIa,S,2CCnBf,W,qBCCA,IAAI8T,EAA8B,EAAQ,QAC1C/U,EAAU+U,GAA4B,GAEtC/U,EAAQgV,KAAK,CAACnV,EAAOC,EAAI,03BAA23B,KAEp5BD,EAAOG,QAAUA,G,qBCLjB,IAAI+U,EAA8B,EAAQ,QAC1C/U,EAAU+U,GAA4B,GAEtC/U,EAAQgV,KAAK,CAACnV,EAAOC,EAAI,inGAAknG,KAE3oGD,EAAOG,QAAUA","file":"js/chunk-2d88eb37.js","sourcesContent":["// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = require(\"!!../../../node_modules/@vue/cli-service/node_modules/css-loader/dist/cjs.js??ref--7-oneOf-1-1!../../../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../../node_modules/@vue/cli-service/node_modules/postcss-loader/src/index.js??ref--7-oneOf-1-2!../../../node_modules/@vue/cli-service/node_modules/postcss-loader/src/index.js??ref--7-oneOf-1-3!../../../node_modules/cache-loader/dist/cjs.js??ref--1-0!../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./FaceCapture.vue?vue&type=style&index=0&id=bc41805e&prod&scoped=true&lang=css\");\nif(content.__esModule) content = content.default;\nif(typeof content === 'string') content = [[module.id, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar add = require(\"!../../../node_modules/vue-style-loader/lib/addStylesClient.js\").default\nvar update = add(\"16c326ee\", content, true, {\"sourceMap\":false,\"shadowMode\":false});","export * from \"-!../../../node_modules/vue-style-loader/index.js??ref--7-oneOf-1-0!../../../node_modules/@vue/cli-service/node_modules/css-loader/dist/cjs.js??ref--7-oneOf-1-1!../../../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../../node_modules/@vue/cli-service/node_modules/postcss-loader/src/index.js??ref--7-oneOf-1-2!../../../node_modules/@vue/cli-service/node_modules/postcss-loader/src/index.js??ref--7-oneOf-1-3!../../../node_modules/cache-loader/dist/cjs.js??ref--1-0!../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./FaceCapture.vue?vue&type=style&index=0&id=4725214a&prod&scoped=true&lang=css\"","// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = require(\"!!../../../node_modules/@vue/cli-service/node_modules/css-loader/dist/cjs.js??ref--7-oneOf-1-1!../../../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../../node_modules/@vue/cli-service/node_modules/postcss-loader/src/index.js??ref--7-oneOf-1-2!../../../node_modules/@vue/cli-service/node_modules/postcss-loader/src/index.js??ref--7-oneOf-1-3!../../../node_modules/cache-loader/dist/cjs.js??ref--1-0!../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./FaceCapture.vue?vue&type=style&index=0&id=4725214a&prod&scoped=true&lang=css\");\nif(content.__esModule) content = content.default;\nif(typeof content === 'string') content = [[module.id, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar add = require(\"!../../../node_modules/vue-style-loader/lib/addStylesClient.js\").default\nvar update = add(\"4bcb3202\", content, true, {\"sourceMap\":false,\"shadowMode\":false});","var render = function render(){var _vm=this,_c=_vm._self._c;return _c('div',{staticClass:\"my-popups\"},[_c('div',{staticClass:\"modal d-block\"},[_c('div',{staticClass:\"modal-dialog modal-dialog-centered ui-draggable\"},[_c('div',{staticClass:\"modal-content\"},[_c('div',{staticClass:\"modal-header ui-draggable-handle py-1\"},[_c('h4',{staticClass:\"modal-title mt-2 pt-1\",attrs:{\"name\":\"header\"}},[_vm._v(\" \"+_vm._s(_vm.$t('FACE_CAPTURE_APP'))+\" \")]),_c('button',{staticClass:\"close\",on:{\"click\":_vm.handleClose}},[_c('em',{staticClass:\"fa fa-times\",attrs:{\"aria-hidden\":\"true\"}})])]),_c('div',{attrs:{\"id\":\"face-preview\"}}),_c('FaceCapture',{ref:\"faceCapture\",staticClass:\"face-capture-wrapper\",on:{\"image-captured\":_vm.detectAndCapture,\"error\":_vm.handleCaptureError}})],1)])])])\n}\nvar staticRenderFns = []\n\nexport { render, staticRenderFns }","import { defineStore } from 'pinia'\r\n\r\nexport const useFaceStore = defineStore('face', {\r\n  state: () => ({\r\n    API_BASE: 'https://faceapi.talygen.com',\r\n    faceDetectedCount: 0,\r\n    captureLimit: 5,\r\n    status: 'Waiting...',\r\n    isCapturing: false\r\n  }),\r\n\r\n  actions: {\r\n    setStatus(message) {\r\n      this.status = message\r\n    },\r\n\r\n    resetCapture() {\r\n      this.faceDetectedCount = 0\r\n      this.status = 'Waiting...'\r\n      this.isCapturing = false\r\n    },\r\n\r\n    incrementCapture() {\r\n      this.faceDetectedCount++\r\n    }\r\n  }\r\n})","var render = function render(){var _vm=this,_c=_vm._self._c;return _c('div',{staticClass:\"face-capture-container\"},[_c('div',{staticClass:\"video-container\"},[_c('video',{directives:[{name:\"show\",rawName:\"v-show\",value:(!_vm.imageCaptured),expression:\"!imageCaptured\"}],ref:\"webcam\",attrs:{\"id\":`webcam-${_vm._uid}`,\"autoplay\":\"\",\"playsinline\":\"\"}}),_c('canvas',{directives:[{name:\"show\",rawName:\"v-show\",value:(!_vm.imageCaptured),expression:\"!imageCaptured\"}],ref:\"canvas\",attrs:{\"id\":`canvas-${_vm._uid}`}}),_c('div',{staticClass:\"capture-flash\",style:({ display: _vm.showFlash ? 'block' : 'none' })}),(_vm.isProcessing)?_c('div',{staticClass:\"processing-overlay\"},[_c('div',{staticClass:\"processing-spinner\"}),_c('p',[_vm._v(_vm._s(_vm.$t('PROCESSING_IMAGE')))])]):_vm._e()]),_c('div',{staticClass:\"status-panel\"},[_c('div',{staticClass:\"status-item\"},[_c('span',{staticClass:\"status-label\"},[_vm._v(_vm._s(_vm.$t('FACE_DETECTION'))+\":\")]),_c('span',{staticClass:\"status-value\",class:_vm.faceStatusClass},[_vm._v(_vm._s(_vm.faceStatusText))])]),_c('div',{staticClass:\"status-item\"},[_c('span',{staticClass:\"status-label\"},[_vm._v(_vm._s(_vm.$t('LIGHTING_CONDITION'))+\":\")]),_c('span',{staticClass:\"status-value\",class:_vm.lightingStatusClass},[_vm._v(_vm._s(_vm.lightingStatusText))])]),_c('div',{staticClass:\"status-item\"},[_c('span',{staticClass:\"status-label\"},[_vm._v(_vm._s(_vm.$t('Distance'))+\":\")]),_c('span',{staticClass:\"status-value\",class:_vm.distanceStatusClass},[_vm._v(_vm._s(_vm.distanceStatusText))])])]),_c('div',{staticClass:\"controls\"},[_c('div',{staticClass:\"stability-indicator\"},[_c('div',{staticClass:\"indicator-dot\",class:_vm.stabilityIndicatorClass}),_c('span',[_vm._v(_vm._s(_vm.stabilityText))])])])])\n}\nvar staticRenderFns = []\n\nexport { render, staticRenderFns }","<template>\r\n  <div class=\"face-capture-container\">\r\n      <div class=\"video-container\">\r\n      <video ref=\"webcam\" :id=\"`webcam-${_uid}`\" autoplay playsinline v-show=\"!imageCaptured\"></video>\r\n      <canvas ref=\"canvas\" :id=\"`canvas-${_uid}`\" v-show=\"!imageCaptured\"></canvas>\r\n      <div class=\"capture-flash\" :style=\"{ display: showFlash ? 'block' : 'none' }\"></div>\r\n      <div v-if=\"isProcessing\" class=\"processing-overlay\">\r\n        <div class=\"processing-spinner\"></div>\r\n        <p>{{ $t('PROCESSING_IMAGE') }}</p>\r\n      </div>\r\n    </div>\r\n\r\n    <div class=\"status-panel\">\r\n      <div class=\"status-item\">\r\n        <span class=\"status-label\">{{ $t('FACE_DETECTION') }}:</span>\r\n        <span class=\"status-value\" :class=\"faceStatusClass\">{{ faceStatusText }}</span>\r\n      </div>\r\n      <div class=\"status-item\">\r\n        <span class=\"status-label\">{{ $t('LIGHTING_CONDITION') }}:</span>\r\n        <span class=\"status-value\" :class=\"lightingStatusClass\">{{ lightingStatusText }}</span>\r\n      </div>\r\n      <div class=\"status-item\">\r\n        <span class=\"status-label\">{{ $t('Distance') }}:</span>\r\n        <span class=\"status-value\" :class=\"distanceStatusClass\">{{ distanceStatusText }}</span>\r\n      </div>\r\n    </div>\r\n\r\n    <div class=\"controls\">\r\n      <div class=\"stability-indicator\">\r\n        <div class=\"indicator-dot\" :class=\"stabilityIndicatorClass\"></div>\r\n        <span>{{ stabilityText }}</span>\r\n      </div>\r\n      <!-- <button\r\n        id=\"captureBtn\"\r\n        :disabled=\"!canCapture\"\r\n        @click=\"manualCapture\"\r\n      >\r\n        <span>CAPTURE IMAGE</span>\r\n      </button> -->\r\n    </div>\r\n  </div>\r\n</template>\r\n\r\n<script>\r\nimport { toRaw, markRaw } from 'vue'\r\n\r\nexport default {\r\n  name: 'FaceCapture',\r\n  emits: ['image-captured', 'error'],\r\n  data() {\r\n    return {\r\n      faceMesh: null,\r\n      canvas: null,\r\n      canvasCtx: null,\r\n      tempCanvas: null,\r\n      tempCanvasCtx: null,\r\n      webcamElement: null,\r\n      stream: null,\r\n      stabilityCounter: 0,\r\n      isCapturing: false,\r\n      STABILITY_THRESHOLD: 25,\r\n      showFlash: false,\r\n      autoCaptureEnabled: true,\r\n      imageCaptured: false, // Track if image has been captured\r\n      isProcessing: false, // Track if processing API response\r\n\r\n      // Analysis variables\r\n      lightingQuality: 0,\r\n      faceDistance: 0,\r\n      hasFace: false,\r\n      allConditionsGood: false,\r\n      previousLandmarks: null\r\n    }\r\n  },\r\n  computed: {\r\n    faceStatusText() {\r\n      return this.hasFace ? this.$t('FACE_DETECTED') : this.$t('SEARCHING')\r\n    },\r\n    faceStatusClass() {\r\n      return this.hasFace ? \"status-good\" : \"status-error\"\r\n    },\r\n    lightingStatusText() {\r\n      if (this.lightingQuality > 0.6) return this.$t('GOOD')\r\n      if (this.lightingQuality > 0.3) return this.$t('MODERATE')\r\n      return this.$t('POOR')\r\n    },\r\n    lightingStatusClass() {\r\n      if (this.lightingQuality > 0.6) return \"status-good\"\r\n      if (this.lightingQuality > 0.3) return \"status-warning\"\r\n      return \"status-error\"\r\n    },\r\n    distanceStatusText() {\r\n      if (this.faceDistance > 1.2) return this.$t('MOVE_FAR')\r\n      if (this.faceDistance < 0.7) return this.$t('MOVE_CLOSER')\r\n      return this.$t('GOOD')\r\n    },\r\n    distanceStatusClass() {\r\n      if (this.faceDistance > 1.2 || this.faceDistance < 0.7) return \"status-error\"\r\n      return \"status-good\"\r\n    },\r\n    stabilityIndicatorClass() {\r\n      if (this.stabilityCounter >= this.STABILITY_THRESHOLD) return \"stable\"\r\n      if (this.stabilityCounter > 0) return \"progress\"\r\n      return \"\"\r\n    },\r\n    stabilityText() {\r\n      if (this.stabilityCounter >= this.STABILITY_THRESHOLD) return this.$t('READY_TO_CAPTURE')\r\n      if (!this.allConditionsGood) return this.$t('ADJUST_POSITION')\r\n      if (this.stabilityCounter > 0) {\r\n        const progress = Math.round((this.stabilityCounter / this.STABILITY_THRESHOLD) * 100)\r\n        return `${this.$t('STABILIZING')}: ${progress}%`\r\n      }\r\n      return this.$t('HOLD_POSITION_STEADY')\r\n    },\r\n    canCapture() {\r\n      return this.stabilityCounter >= this.STABILITY_THRESHOLD && !this.isCapturing && !this.imageCaptured\r\n    }\r\n  },\r\n  mounted() {\r\n    // Wait for next tick to ensure DOM is ready, especially for conditionally rendered components\r\n    this.$nextTick(() => {\r\n      setTimeout(() => this.init(), 200)\r\n    })\r\n  },\r\n  beforeUnmount() {\r\n    this.stopCamera()\r\n  },\r\n    beforeDestroy() {\r\n    this.stopCamera()\r\n  },\r\n  methods: {\r\n  async init() {\r\n  try {\r\n    await this.$nextTick();\r\n\r\n    let webcamElement = this.$refs.webcam;\r\n    let canvasElement = this.$refs.canvas;\r\n\r\n    // Check if the webcam and canvas elements exist\r\n    if (!webcamElement || !canvasElement) {\r\n      await new Promise(resolve => setTimeout(resolve, 300));\r\n      webcamElement = this.$refs.webcam;\r\n      canvasElement = this.$refs.canvas;\r\n\r\n      if (!webcamElement || !canvasElement) {\r\n        throw new Error(this.$t('VIDEO_OR_CANVAS_NOT_FOUND'));\r\n      }\r\n    }\r\n\r\n    this.webcamElement = webcamElement;\r\n    this.canvas = canvasElement;\r\n    this.canvasCtx = this.canvas.getContext(\"2d\");\r\n\r\n    // Wait for MediaPipe and initialize face mesh\r\n    await this.waitForMediaPipe();\r\n    if (!this.initializeFaceMesh()) {\r\n      throw new Error(this.$t('FACEMESH_INITIALIZATION_FAILED'));\r\n    }\r\n\r\n    // Check for camera permission\r\n    if (!navigator.mediaDevices?.getUserMedia) {\r\n      throw new Error(this.$t('CAMERA_NOT_SUPPORTED'));\r\n    }\r\n\r\n    // Try to get the camera stream\r\n    const stream = await this.getCameraStream();\r\n\r\n    this.stream = stream;\r\n    this.webcamElement.srcObject = stream;\r\n\r\n    // Wait for the video to be ready\r\n    await new Promise((resolve, reject) => {\r\n      const timeout = setTimeout(() => reject(new Error(this.$t('VIDEO_TIMEOUT'))), 10000);\r\n\r\n      this.webcamElement.onloadedmetadata = () => {\r\n        clearTimeout(timeout);\r\n        this.forceVideoFit();\r\n        resolve();\r\n      };\r\n\r\n      this.webcamElement.onerror = (err) => {\r\n        clearTimeout(timeout);\r\n        reject(err);\r\n      };\r\n    });\r\n\r\n    this.forceVideoFit();\r\n    this.processFrame();\r\n  } catch (error) {\r\n    this.$emit(\"error\", error);\r\n  }\r\n},\r\n\r\n// Function to handle camera stream and permission\r\nasync getCameraStream() {\r\n  try {\r\n    // Attempt to get the camera stream\r\n    const stream = await navigator.mediaDevices.getUserMedia({ video: true });\r\n  \r\n    return stream;\r\n  } catch (error) {\r\n    if (error.name === 'NotAllowedError' || error.name === 'NotFoundError') {\r\n      // Handle permission denial or camera not found\r\n      const permissionError = new Error(this.$t('CAMERA_PERMISSION_DENIED'));\r\n      permissionError.code = 'PERMISSION_DENIED';\r\n      this.$emit('error', permissionError);\r\n\r\n      // Optionally, you can prompt the user to try again\r\n     // await this.promptForCameraPermission();\r\n    } else {\r\n      // Handle other errors\r\n      this.$emit('error', error);\r\n      throw error;\r\n    }\r\n  }\r\n},\r\n\r\n// Function to prompt the user for camera permission\r\nasync promptForCameraPermission() {\r\n  try {\r\n    // Show a native confirmation dialog asking the user to allow camera access\r\n    const userResponse = window.confirm(this.$t('ALLOW_CAMERA_PERMISSION'));\r\n\r\n    if (userResponse) {\r\n      // If the user accepts, try to get the camera stream again\r\n      await this.getCameraStream();\r\n    } else {\r\n      // If the user denies, throw an error\r\n      throw new Error(this.$t('CAMERA_PERMISSION_REQUIRED'));\r\n    }\r\n  } catch (error) {\r\n    // Handle cases where the user denies permission or other errors\r\n    console.error('Camera permission was not granted:', error);\r\n    this.$emit('error', error);\r\n  }\r\n},\r\n\r\n    async waitForMediaPipe() {\r\n      // First check if already available\r\n      if (window.FaceMesh) {\r\n        return\r\n      }\r\n\r\n      // Wait a bit for scripts to load\r\n      await new Promise(resolve => setTimeout(resolve, 500))\r\n\r\n      // Check again after short delay\r\n      if (window.FaceMesh) {\r\n        return\r\n      }\r\n\r\n      // Try to load scripts dynamically if not found\r\n      if (!window.FaceMesh && document.readyState === 'complete') {\r\n        await this.loadMediaPipeScripts()\r\n      }\r\n\r\n      // Poll for FaceMesh with longer timeout\r\n      return new Promise((resolve, reject) => {\r\n        let attempts = 0\r\n        const maxAttempts = 200 // 20 seconds\r\n\r\n        const checkInterval = setInterval(() => {\r\n          attempts++\r\n\r\n          // Check multiple possible locations\r\n          const FaceMeshAvailable =\r\n            window.FaceMesh ||\r\n            window.self?.FaceMesh ||\r\n            (typeof FaceMesh !== 'undefined' ? FaceMesh : null) ||\r\n            window.mediapipe?.FaceMesh\r\n\r\n          if (FaceMeshAvailable) {\r\n            if (!window.FaceMesh && FaceMeshAvailable) {\r\n              window.FaceMesh = FaceMeshAvailable\r\n            }\r\n            clearInterval(checkInterval)\r\n            resolve()\r\n          } else if (attempts >= maxAttempts) {\r\n            clearInterval(checkInterval)\r\n            console.error('FaceMesh not found. Available globals:', {\r\n              hasWindowFaceMesh: !!window.FaceMesh,\r\n              hasSelfFaceMesh: !!window.self?.FaceMesh,\r\n              hasMediaPipe: !!window.mediapipe,\r\n              windowKeys: Object.keys(window).filter(k =>\r\n                k.toLowerCase().includes('face') ||\r\n                k.toLowerCase().includes('mesh') ||\r\n                k.toLowerCase().includes('mediapipe')\r\n              )\r\n            })\r\n            reject(new Error(this.$t('FACEMESH_NOT_AVAILABLE')))\r\n          }\r\n        }, 100)\r\n      })\r\n    },\r\n\r\n    loadMediaPipeScripts() {\r\n      return new Promise((resolve, reject) => {\r\n        const scripts = [\r\n          'https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils@0.3/camera_utils.js',\r\n          'https://cdn.jsdelivr.net/npm/@mediapipe/control_utils@0.3/control_utils.js',\r\n          'https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils@0.3/drawing_utils.js',\r\n          'https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh@0.4/face_mesh.js'\r\n        ]\r\n\r\n        let loaded = 0\r\n        const total = scripts.length\r\n\r\n        scripts.forEach((src, index) => {\r\n          // Check if script already exists\r\n          const existing = document.querySelector(`script[src=\"${src}\"]`)\r\n          if (existing) {\r\n            loaded++\r\n            if (loaded === total) resolve()\r\n            return\r\n          }\r\n\r\n          const script = document.createElement('script')\r\n          script.src = src\r\n          script.crossOrigin = 'anonymous'\r\n          script.onload = () => {\r\n            loaded++\r\n            console.log(`Loaded script ${index + 1}/${total}: ${src}`)\r\n            if (loaded === total) {\r\n              resolve()\r\n            }\r\n          }\r\n          script.onerror = () => {\r\n            reject(new Error(`Failed to load MediaPipe script: ${src}`))\r\n          }\r\n          window.top.document.head.appendChild(script)\r\n        })\r\n      })\r\n    },\r\n\r\n    initializeFaceMesh() {\r\n      const FaceMeshClass = \r\n    window.FaceMesh || \r\n    (window.module && window.module.FaceMesh);\r\n\r\nif (!FaceMeshClass || typeof FaceMeshClass !== \"function\") {\r\n    return false;\r\n}\r\n\r\n      try {\r\n        const faceMeshInstance = new FaceMeshClass({\r\n          locateFile: (file) => {\r\n            return `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`\r\n          }\r\n        })\r\n\r\n        faceMeshInstance.setOptions({\r\n          maxNumFaces: 1,\r\n          refineLandmarks: true,\r\n          minDetectionConfidence: 0.5,\r\n          minTrackingConfidence: 0.5\r\n        })\r\n\r\n        faceMeshInstance.onResults(this.onFaceMeshResults.bind(this))\r\n        this.faceMesh = faceMeshInstance\r\n        return true\r\n      } catch (error) {\r\n        return false\r\n      }\r\n    },\r\n\r\n    async processFrame() {\r\n  // Stop if image already captured\r\n  if (this.imageCaptured) return;\r\n\r\n  if (!this.stream || !this.webcamElement) return;\r\n\r\n  const videoElement = this.$refs.webcam;\r\n  if (!videoElement) return;\r\n\r\n  // Ensure video metadata is ready\r\n  if (videoElement.readyState < videoElement.HAVE_METADATA) {\r\n    requestAnimationFrame(() => this.processFrame());\r\n    return;\r\n  }\r\n\r\n  // If FaceMesh is available\r\n  if (this.faceMesh) {\r\n    try {\r\n      // Create temp canvas (once)\r\n      if (!this.tempCanvas) {\r\n        this.tempCanvas = document.createElement(\"canvas\");\r\n        this.tempCanvasCtx = this.tempCanvas.getContext(\"2d\");\r\n      }\r\n\r\n      // Resize temp canvas to video resolution\r\n      if (\r\n        this.tempCanvas.width !== videoElement.videoWidth ||\r\n        this.tempCanvas.height !== videoElement.videoHeight\r\n      ) {\r\n        this.tempCanvas.width = videoElement.videoWidth;\r\n        this.tempCanvas.height = videoElement.videoHeight;\r\n      }\r\n\r\n      // Draw current video frame\r\n      this.tempCanvasCtx.drawImage(\r\n        videoElement,\r\n        0,\r\n        0,\r\n        this.tempCanvas.width,\r\n        this.tempCanvas.height\r\n      );\r\n\r\n      // Send to FaceMesh\r\n      await this.faceMesh.send({ image: this.tempCanvas });\r\n    } catch (error) {\r\n    }\r\n  }\r\n\r\n  // If no FaceMesh, draw video on main canvas\r\n  else {\r\n    if (\r\n      this.canvas &&\r\n      this.canvasCtx &&\r\n      videoElement.videoWidth > 0 &&\r\n      videoElement.videoHeight > 0\r\n    ) {\r\n      if (\r\n        this.canvas.width !== videoElement.videoWidth ||\r\n        this.canvas.height !== videoElement.videoHeight\r\n      ) {\r\n        this.canvas.width = videoElement.videoWidth;\r\n        this.canvas.height = videoElement.videoHeight;\r\n      }\r\n      this.canvasCtx.drawImage(videoElement, 0, 0, this.canvas.width, this.canvas.height);\r\n    }\r\n  }\r\n\r\n  requestAnimationFrame(() => this.processFrame());\r\n},\r\n\r\n    onFaceMeshResults(results) {\r\n      // Stop processing if image has been captured\r\n      if (this.imageCaptured) return\r\n\r\n      if (!this.canvas || !this.canvasCtx) return\r\n\r\n      // Use ref instead of getElementById\r\n      const videoElement = this.$refs.webcam\r\n      if (!videoElement) return\r\n\r\n      // Get container dimensions (video container, not video element)\r\n      const container = videoElement.parentElement\r\n      if (!container) return\r\n\r\n      const containerWidth = container.clientWidth\r\n      const containerHeight = container.clientHeight\r\n\r\n      // Set canvas to match container size (for overlay drawing)\r\n      if (this.canvas.width !== containerWidth ||\r\n          this.canvas.height !== containerHeight) {\r\n        this.canvas.width = containerWidth\r\n        this.canvas.height = containerHeight\r\n      }\r\n\r\n      // Canvas is only for overlay (face box) - video element shows the actual feed\r\n      this.canvasCtx.save()\r\n      this.canvasCtx.clearRect(0, 0, this.canvas.width, this.canvas.height)\r\n\r\n      // Analyze lighting from the results image\r\n      this.analyzeLightingConditions(results.image)\r\n\r\n      // Only process if we have valid face landmarks and not currently capturing\r\n      if (results.multiFaceLandmarks && results.multiFaceLandmarks.length > 0 && !this.isCapturing) {\r\n        // Validate that landmarks are actually valid (not false positives)\r\n        const landmarks = results.multiFaceLandmarks[0]\r\n\r\n        // Check if landmarks are valid by verifying key points exist and are reasonable\r\n        if (this.isValidFaceLandmarks(landmarks)) {\r\n          this.hasFace = true\r\n\r\n          this.analyzeFaceConditions(landmarks)\r\n          this.checkFaceStability(landmarks)\r\n\r\n          // Draw face detection box\r\n          this.drawFaceBox(landmarks)\r\n        } else {\r\n          // Invalid landmarks - likely false positive\r\n          this.hasFace = false\r\n          this.stabilityCounter = 0\r\n        }\r\n      } else {\r\n        this.hasFace = false\r\n        this.stabilityCounter = 0\r\n      }\r\n\r\n      this.canvasCtx.restore()\r\n    },\r\n\r\n    drawFaceBox(landmarks) {\r\n      if (!this.canvas || !this.canvasCtx || !this.hasFace) return\r\n\r\n      if (!landmarks || landmarks.length < 468) return\r\n\r\n      // Get video element to calculate proper scaling\r\n      const videoElement = this.$refs.webcam\r\n      if (!videoElement || !videoElement.videoWidth) return\r\n\r\n      const container = videoElement.parentElement\r\n      if (!container) return\r\n\r\n      const containerWidth = container.clientWidth\r\n      const containerHeight = container.clientHeight\r\n\r\n      // Calculate how the video is displayed (contain mode)\r\n      const videoAspect = videoElement.videoWidth / videoElement.videoHeight\r\n      const containerAspect = containerWidth / containerHeight\r\n\r\n      let videoDisplayWidth, videoDisplayHeight, videoOffsetX, videoOffsetY\r\n\r\n      if (videoAspect > containerAspect) {\r\n        // Video is wider - fits to container width\r\n        videoDisplayWidth = containerWidth\r\n        videoDisplayHeight = containerWidth / videoAspect\r\n        videoOffsetX = 0\r\n        videoOffsetY = (containerHeight - videoDisplayHeight) / 2\r\n      } else {\r\n        // Video is taller - fits to container height\r\n        videoDisplayHeight = containerHeight\r\n        videoDisplayWidth = containerHeight * videoAspect\r\n        videoOffsetX = (containerWidth - videoDisplayWidth) / 2\r\n        videoOffsetY = 0\r\n      }\r\n\r\n      // Scale landmarks from video coordinates (0-1) to container coordinates\r\n      const scaleX = videoDisplayWidth / videoElement.videoWidth\r\n      const scaleY = videoDisplayHeight / videoElement.videoHeight\r\n\r\n      const width = this.canvas.width\r\n      const height = this.canvas.height\r\n\r\n      // Get key face points\r\n      const leftEye = landmarks[33]\r\n      const rightEye = landmarks[263]\r\n      const noseTip = landmarks[1]\r\n      const chin = landmarks[152]\r\n      const leftEar = landmarks[234]\r\n      const rightEar = landmarks[454]\r\n\r\n      // Validate key points exist\r\n      if (!leftEye || !rightEye || !noseTip || !chin || !leftEar || !rightEar) {\r\n        return\r\n      }\r\n\r\n      // Calculate face bounds in video coordinates (0-1)\r\n      const minX = Math.min(leftEar.x, rightEar.x, leftEye.x, rightEye.x)\r\n      const maxX = Math.max(leftEar.x, rightEar.x, leftEye.x, rightEye.x)\r\n      const minY = Math.min(leftEye.y, rightEye.y, noseTip.y)\r\n      const maxY = Math.max(chin.y, noseTip.y)\r\n\r\n      const faceCenterX = (minX + maxX) / 2\r\n      const faceCenterY = (minY + maxY) / 2\r\n      const faceWidth = (maxX - minX) * 1.6\r\n      const faceHeight = (maxY - minY) * 2.0\r\n\r\n      // Convert to container coordinates\r\n      const faceCenterXContainer = videoOffsetX + (faceCenterX * videoElement.videoWidth * scaleX)\r\n      const faceCenterYContainer = videoOffsetY + (faceCenterY * videoElement.videoHeight * scaleY)\r\n      const faceWidthContainer = faceWidth * videoElement.videoWidth * scaleX\r\n      const faceHeightContainer = faceHeight * videoElement.videoHeight * scaleY\r\n\r\n      // Validate face bounds are reasonable\r\n      if (faceWidth <= 0 || faceHeight <= 0 ||\r\n          faceWidth > 2 || faceHeight > 2) {\r\n        return\r\n      }\r\n\r\n      // Determine box color based on conditions\r\n      let boxColor = '#ff6b6b' // Red - not ready\r\n      if (this.allConditionsGood) {\r\n        boxColor = '#00ff88' // Green - ready\r\n      } else if (this.hasFace) {\r\n        boxColor = '#ffaa00' // Orange - adjusting\r\n      }\r\n\r\n      // Draw face box in container coordinates\r\n      this.canvasCtx.strokeStyle = boxColor\r\n      this.canvasCtx.lineWidth = 3\r\n      this.canvasCtx.setLineDash([])\r\n\r\n      this.canvasCtx.beginPath()\r\n      this.canvasCtx.rect(\r\n        faceCenterXContainer - faceWidthContainer/2,\r\n        faceCenterYContainer - faceHeightContainer/2,\r\n        faceWidthContainer,\r\n        faceHeightContainer\r\n      )\r\n      this.canvasCtx.stroke()\r\n\r\n      if (this.allConditionsGood && this.stabilityCounter > 0) {\r\n        const progress = this.stabilityCounter / this.STABILITY_THRESHOLD\r\n        this.canvasCtx.strokeStyle = '#00ff88'\r\n        this.canvasCtx.lineWidth = 4\r\n        this.canvasCtx.beginPath()\r\n        this.canvasCtx.rect(\r\n          faceCenterXContainer - faceWidthContainer/2,\r\n          faceCenterYContainer - faceHeightContainer/2,\r\n          faceWidthContainer * progress,\r\n          faceHeightContainer\r\n        )\r\n        this.canvasCtx.stroke()\r\n      }\r\n    },\r\n\r\n    isValidFaceLandmarks(landmarks) {\r\n      if (!landmarks || landmarks.length < 468) {\r\n        return false\r\n      }\r\n\r\n      // Check key face points exist and are within valid bounds (0-1)\r\n      const keyPoints = [33, 263, 1, 152, 234, 454] // eyes, nose, chin, ears\r\n\r\n      for (const index of keyPoints) {\r\n        const point = landmarks[index]\r\n        if (!point ||\r\n            typeof point.x !== 'number' ||\r\n            typeof point.y !== 'number' ||\r\n            point.x < 0 || point.x > 1 ||\r\n            point.y < 0 || point.y > 1) {\r\n          return false\r\n        }\r\n      }\r\n\r\n      // Check face size - if too small, likely false positive\r\n      const leftEye = landmarks[33]\r\n      const rightEye = landmarks[263]\r\n      const noseTip = landmarks[1]\r\n      const chin = landmarks[152]\r\n\r\n      const eyeDistance = Math.abs((rightEye.x - leftEye.x))\r\n      const faceHeight = Math.abs((chin.y - noseTip.y))\r\n\r\n      // Face should be at least 5% of frame width and height\r\n      if (eyeDistance < 0.05 || faceHeight < 0.05) {\r\n        return false\r\n      }\r\n\r\n      // Face should not be too large (unlikely to be > 80% of frame)\r\n      if (eyeDistance > 0.8 || faceHeight > 0.8) {\r\n        return false\r\n      }\r\n\r\n      // Check if face is reasonably centered (not completely off-screen)\r\n      const faceCenterX = (leftEye.x + rightEye.x) / 2\r\n      const faceCenterY = (noseTip.y + chin.y) / 2\r\n\r\n      // Face center should be within frame bounds (with some margin)\r\n      if (faceCenterX < -0.2 || faceCenterX > 1.2 ||\r\n          faceCenterY < -0.2 || faceCenterY > 1.2) {\r\n        return false\r\n      }\r\n\r\n      return true\r\n    },\r\n\r\n    analyzeLightingConditions(imageData) {\r\n      const tempCanvas = document.createElement('canvas')\r\n      const tempCtx = tempCanvas.getContext('2d')\r\n      tempCanvas.width = 100\r\n      tempCanvas.height = 100\r\n      tempCtx.drawImage(imageData, 0, 0, 100, 100)\r\n\r\n      const imageDataObj = tempCtx.getImageData(0, 0, 100, 100)\r\n      const data = imageDataObj.data\r\n\r\n      let totalBrightness = 0\r\n      let pixelCount = 0\r\n\r\n      for (let i = 0; i < data.length; i += 4) {\r\n        const r = data[i]\r\n        const g = data[i + 1]\r\n        const b = data[i + 2]\r\n        const brightness = (r + g + b) / 3\r\n        totalBrightness += brightness\r\n        pixelCount++\r\n      }\r\n\r\n      const avgBrightness = totalBrightness / pixelCount\r\n      this.lightingQuality = avgBrightness / 255\r\n    },\r\n\r\n    analyzeFaceConditions(landmarks) {\r\n      if (!landmarks || landmarks.length < 468) {\r\n        this.hasFace = false\r\n        this.allConditionsGood = false\r\n        return\r\n      }\r\n\r\n      const leftEye = landmarks[33]\r\n      const rightEye = landmarks[263]\r\n      const noseTip = landmarks[1]\r\n      const chin = landmarks[152]\r\n\r\n      // Validate key points exist\r\n      if (!leftEye || !rightEye || !noseTip || !chin) {\r\n        this.hasFace = false\r\n        this.allConditionsGood = false\r\n        return\r\n      }\r\n\r\n      const eyeDistance = Math.abs((rightEye.x - leftEye.x)) * this.canvas.width\r\n      const faceHeight = Math.abs((chin.y - noseTip.y)) * this.canvas.height\r\n      const faceSize = (eyeDistance + faceHeight) / 2\r\n\r\n      // Only calculate distance if face size is reasonable\r\n      if (faceSize < 50 || faceSize > 500) {\r\n        // Face too small or too large - likely invalid\r\n        this.hasFace = false\r\n        this.allConditionsGood = false\r\n        return\r\n      }\r\n\r\n      if (faceSize < 100) {\r\n        this.faceDistance = 0.4\r\n      } else if (faceSize > 300) {\r\n        this.faceDistance = 1.5\r\n      } else {\r\n        this.faceDistance = 0.8 + (faceSize - 100) / 200\r\n      }\r\n\r\n      // Check face visibility - ensure key points are within frame\r\n      const keyPoints = [33, 263, 1, 152, 234, 454]\r\n      let pointsInFrame = 0\r\n      for (const pointIndex of keyPoints) {\r\n        const point = landmarks[pointIndex]\r\n        if (point && point.x >= 0.05 && point.x <= 0.95 &&\r\n            point.y >= 0.05 && point.y <= 0.95) {\r\n          pointsInFrame++\r\n        }\r\n      }\r\n\r\n      // At least 4 out of 6 key points should be in frame\r\n      const faceVisible = pointsInFrame >= 4\r\n\r\n      this.allConditionsGood = this.lightingQuality > 0.3 &&\r\n                                this.faceDistance >= 0.7 && this.faceDistance <= 1.2 &&\r\n                                this.hasFace && faceVisible\r\n    },\r\n\r\n    checkFaceStability(landmarks) {\r\n      if (!this.previousLandmarks || this.isCapturing) {\r\n        this.previousLandmarks = landmarks\r\n        return\r\n      }\r\n\r\n      if (!this.allConditionsGood) {\r\n        this.stabilityCounter = 0\r\n        this.previousLandmarks = landmarks\r\n        return\r\n      }\r\n\r\n      let totalMovement = 0\r\n      const numLandmarks = Math.min(landmarks.length, this.previousLandmarks.length, 50)\r\n\r\n      for (let i = 0; i < numLandmarks; i++) {\r\n        const dx = landmarks[i].x - this.previousLandmarks[i].x\r\n        const dy = landmarks[i].y - this.previousLandmarks[i].y\r\n        totalMovement += Math.sqrt(dx * dx + dy * dy)\r\n      }\r\n\r\n      const avgMovement = totalMovement / numLandmarks\r\n\r\n      if (avgMovement < 0.003) {\r\n        this.stabilityCounter = Math.min(this.stabilityCounter + 2, this.STABILITY_THRESHOLD)\r\n      } else {\r\n        this.stabilityCounter = Math.max(this.stabilityCounter - 3, 0)\r\n      }\r\n\r\n      // Auto-capture when stable and conditions are good (only if not already captured)\r\n      if (this.stabilityCounter >= this.STABILITY_THRESHOLD &&\r\n          this.autoCaptureEnabled &&\r\n          !this.isCapturing &&\r\n          !this.imageCaptured) {\r\n        this.capturePhoto()\r\n      }\r\n\r\n      this.previousLandmarks = landmarks\r\n    },\r\n\r\n    capturePhoto() {\r\n  if (this.isCapturing || !this.allConditionsGood || this.imageCaptured) return;\r\n\r\n  this.isCapturing = true;\r\n  this.imageCaptured = true;\r\n  this.autoCaptureEnabled = false;\r\n\r\n  this.showFlash = true;\r\n  setTimeout(() => {\r\n    this.showFlash = false;\r\n  }, 300);\r\n\r\n  const videoElement = this.$refs.webcam;\r\n  if (!videoElement) return;\r\n\r\n  //  Capture BEFORE stopping camera\r\n  const tempCanvas = document.createElement(\"canvas\");\r\n  tempCanvas.width = videoElement.videoWidth;\r\n  tempCanvas.height = videoElement.videoHeight;\r\n  const tempCtx = tempCanvas.getContext(\"2d\");\r\n\r\n  tempCtx.drawImage(videoElement, 0, 0, tempCanvas.width, tempCanvas.height);\r\n\r\n  const dataUrl = tempCanvas.toDataURL(\"image/jpeg\", 0.9);\r\n\r\n  // Now safe to stop camera \r\n  this.stopCamera();\r\n\r\n  // Now emit captured image\r\n  this.isProcessing = true;\r\n  this.$emit(\"image-captured\", {\r\n    imageData: dataUrl, // now valid\r\n    imageBlob: null\r\n  });\r\n},\r\n\r\n    // Method to reset after API processing is complete (called by parent if needed)\r\n    resetCapture() {\r\n      this.imageCaptured = false\r\n      this.isCapturing = false\r\n      this.isProcessing = false\r\n      this.stabilityCounter = 0\r\n      this.autoCaptureEnabled = true\r\n    },\r\n\r\n    manualCapture() {\r\n      if (!this.isCapturing && this.allConditionsGood && !this.imageCaptured) {\r\n        this.capturePhoto()\r\n      }\r\n    },\r\n\r\n    stopCamera() {\r\n      if (this.stream) {\r\n        this.stream.getTracks().forEach(track => track.stop())\r\n        this.stream = null\r\n      }\r\n      if (this.webcamElement) {\r\n        this.webcamElement.srcObject = null\r\n      }\r\n    },\r\n\r\n    forceVideoFit() {\r\n      const videoEl = this.$refs.webcam\r\n      if (!videoEl) return\r\n\r\n      const container = videoEl.parentElement\r\n      if (!container) return\r\n\r\n      // Force video to fit container\r\n      videoEl.style.width = container.clientWidth + 'px'\r\n      videoEl.style.height = container.clientHeight + 'px'\r\n      videoEl.style.maxWidth = '100%'\r\n      videoEl.style.maxHeight = '100%'\r\n      videoEl.style.objectFit = 'contain'\r\n      videoEl.style.position = 'absolute'\r\n      videoEl.style.top = '0'\r\n      videoEl.style.left = '0'\r\n    }\r\n  }\r\n}\r\n</script>\r\n\r\n<style scoped>\r\n.face-capture-container {\r\n  width: 100%;\r\n  max-width: 600px;\r\n  margin: 0 auto;\r\n}\r\n\r\n.video-container {\r\n    position: relative;\r\n    width: 100%;\r\n    height: 340px !important;\r\n    padding-bottom: 0;\r\n    background: #ffffff;\r\n    border-radius: 0;\r\n    overflow: hidden;\r\n    border: 2px solid rgba(255, 255, 255, 0.1);\r\n    margin-bottom: 20px;\r\n    box-sizing: border-box;\r\n}\r\n\r\n.video-container video {\r\n  position: absolute;\r\n  top: 0;\r\n  left: 0;\r\n  width: 100% !important;\r\n  height: 100% !important;\r\n  max-width: 100% !important;\r\n  max-height: 100% !important;\r\n  object-fit: contain !important;\r\n  transform: scaleX(-1);\r\n  background: #000;\r\n  box-sizing: border-box;\r\n}\r\n\r\n.video-container canvas {\r\n  position: absolute;\r\n  top: 0;\r\n  left: 0;\r\n  width: 100% !important;\r\n  height: 100% !important;\r\n  max-width: 100% !important;\r\n  max-height: 100% !important;\r\n  transform: scaleX(-1);\r\n  pointer-events: none;\r\n  object-fit: contain;\r\n  box-sizing: border-box;\r\n}\r\n\r\n.capture-flash {\r\n  position: absolute;\r\n  top: 0;\r\n  left: 0;\r\n  width: 100%;\r\n  height: 100%;\r\n  background: rgba(255, 255, 255, 0.9);\r\n  z-index: 15;\r\n  animation: flash 0.3s ease-out;\r\n}\r\n\r\n@keyframes flash {\r\n  0% { opacity: 1; }\r\n  100% { opacity: 0; }\r\n}\r\n\r\n.status-panel {\r\n  display: flex;\r\n  flex-direction: column;\r\n  gap: 10px;\r\n  margin-bottom: 20px;\r\n}\r\n\r\n.status-item {\r\n  display: flex;\r\n  justify-content: space-between;\r\n  align-items: center;\r\n  padding: 8px 12px;\r\n  background: rgba(255, 255, 255, 0.05);\r\n  border-radius: 8px;\r\n}\r\n\r\n.status-label {\r\n  flex: 1;\r\n  font-weight: 500;\r\n}\r\n\r\n.status-value {\r\n  font-weight: bold;\r\n}\r\n\r\n.status-good {\r\n  color: #27ae60;\r\n}\r\n\r\n.status-warning {\r\n  color: #f39c12;\r\n}\r\n\r\n.status-error {\r\n  color: #c0392b;\r\n}\r\n\r\n.controls {\r\n  display: flex;\r\n  flex-direction: column;\r\n  align-items: center;\r\n  gap: 15px;\r\n}\r\n\r\n.stability-indicator {\r\n  display: flex;\r\n  align-items: center;\r\n  gap: 12px;\r\n  margin-bottom: 10px;\r\n  padding: 12px 20px;\r\n  background: rgba(255, 255, 255, 0.1);\r\n  border-radius: 25px;\r\n}\r\n\r\n.indicator-dot {\r\n  width: 16px;\r\n  height: 16px;\r\n  border-radius: 50%;\r\n  background-color: #c0392b;\r\n  transition: all 0.3s ease;\r\n}\r\n\r\n.indicator-dot.stable {\r\n  background-color: #27ae60;\r\n  box-shadow: none;\r\n}\r\n\r\n.indicator-dot.progress {\r\n  background-color:  #f39c12;\r\n  box-shadow: none;\r\n}\r\n\r\n#captureBtn {\r\n  background: linear-gradient(135deg, #00b894, #00a085);\r\n  color: white;\r\n  border: none;\r\n  padding: 14px 30px;\r\n  font-size: 1.1rem;\r\n  border-radius: 50px;\r\n  cursor: pointer;\r\n  transition: all 0.3s ease;\r\n  box-shadow: 0 6px 20px rgba(0, 184, 148, 0.4);\r\n  font-weight: bold;\r\n  width: 100%;\r\n  max-width: 300px;\r\n}\r\n\r\n#captureBtn:hover:not(:disabled) {\r\n  transform: translateY(-3px);\r\n  box-shadow: 0 8px 25px rgba(0, 184, 148, 0.6);\r\n}\r\n\r\n#captureBtn:disabled {\r\n  background: linear-gradient(135deg, #636e72, #2d3436);\r\n  cursor: not-allowed;\r\n  transform: none;\r\n  box-shadow: none;\r\n}\r\n\r\n.processing-overlay {\r\n  position: absolute;\r\n  top: 0;\r\n  left: 0;\r\n  width: 100%;\r\n  height: 100%;\r\n  background: rgba(0, 0, 0, 0.8);\r\n  display: flex;\r\n  flex-direction: column;\r\n  align-items: center;\r\n  justify-content: center;\r\n  z-index: 20;\r\n  border-radius: 12px;\r\n  color: white;\r\n}\r\n\r\n.processing-spinner {\r\n  border: 4px solid rgba(255, 255, 255, 0.3);\r\n  border-top: 4px solid #00ff88;\r\n  border-radius: 50%;\r\n  width: 50px;\r\n  height: 50px;\r\n  animation: spin 1s linear infinite;\r\n  margin-bottom: 15px;\r\n}\r\n\r\n.processing-overlay p {\r\n  font-size: 1.1rem;\r\n  font-weight: 500;\r\n}\r\n\r\n@keyframes spin {\r\n  0% { transform: rotate(0deg); }\r\n  100% { transform: rotate(360deg); }\r\n}\r\n</style>\r\n\r\n","import mod from \"-!../../../node_modules/cache-loader/dist/cjs.js??ref--13-0!../../../node_modules/thread-loader/dist/cjs.js!../../../node_modules/babel-loader/lib/index.js!../../../node_modules/cache-loader/dist/cjs.js??ref--1-0!../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./FaceCapture.vue?vue&type=script&lang=js\"; export default mod; export * from \"-!../../../node_modules/cache-loader/dist/cjs.js??ref--13-0!../../../node_modules/thread-loader/dist/cjs.js!../../../node_modules/babel-loader/lib/index.js!../../../node_modules/cache-loader/dist/cjs.js??ref--1-0!../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./FaceCapture.vue?vue&type=script&lang=js\"","import { render, staticRenderFns } from \"./FaceCapture.vue?vue&type=template&id=bc41805e&scoped=true\"\nimport script from \"./FaceCapture.vue?vue&type=script&lang=js\"\nexport * from \"./FaceCapture.vue?vue&type=script&lang=js\"\nimport style0 from \"./FaceCapture.vue?vue&type=style&index=0&id=bc41805e&prod&scoped=true&lang=css\"\n\n\n/* normalize component */\nimport normalizer from \"!../../../node_modules/vue-loader/lib/runtime/componentNormalizer.js\"\nvar component = normalizer(\n  script,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  \"bc41805e\",\n  null\n  \n)\n\nexport default component.exports","<template>\r\n  <div class=\"my-popups\">\r\n    <div class=\"modal d-block\">\r\n      <div class=\"modal-dialog modal-dialog-centered ui-draggable\">\r\n        <div class=\"modal-content\">\r\n          <div class=\"modal-header ui-draggable-handle py-1\">\r\n            <h4 name=\"header\" class=\"modal-title mt-2 pt-1\">\r\n              {{ $t('FACE_CAPTURE_APP') }}\r\n            </h4>\r\n            <button class=\"close\" @click=\"handleClose\">\r\n              <em aria-hidden=\"true\" class=\"fa fa-times\"></em>\r\n            </button>\r\n          </div>\r\n          <div id=\"face-preview\"></div>\r\n          <!-- <div class=\"videocontainer\">\r\n            <div v-if=\"isLoading\" class=\"loader-overlay\">\r\n              <div class=\"spinner\"></div>\r\n            </div>\r\n\r\n            <video ref=\"video\" autoplay muted playsinline></video>\r\n            <canvas ref=\"canvas\" style=\"display:none;\"></canvas>\r\n          </div> -->\r\n           \r\n          <FaceCapture ref=\"faceCapture\" @image-captured=\"detectAndCapture\" @error=\"handleCaptureError\"\r\n            class=\"face-capture-wrapper\" />\r\n\r\n        </div>\r\n      </div>\r\n    </div>\r\n  </div>\r\n</template>\r\n<script>\r\nimport { useFaceStore } from \"@/stores/faceStore\";\r\nimport DataService from \"../../services/DataService\";\r\nimport FaceCapture from \"../../components/Modals/FaceCapture.vue\";\r\nexport default {\r\n  components: {\r\n    FaceCapture\r\n  },\r\n  props: {\r\n    id: {\r\n      type: Number,\r\n      required: true,\r\n    },\r\n    name: {\r\n      type: String,\r\n      required: true,\r\n    },\r\n  },\r\n  data() {\r\n    return {\r\n      isLoading: false,\r\n      \r\n    };\r\n  },\r\n  computed: {\r\n    store() {\r\n      return useFaceStore();\r\n    },\r\n  },\r\n  mounted() {\r\n    this.store.resetCapture();\r\n  },\r\n  methods: {\r\n    async checkNameExists(id) {\r\n      try {\r\n        const raw = JSON.stringify({\r\n          companyId: String(this.GetUserInfo.CompanyId),\r\n          id: String(id)\r\n        });\r\n        // Always define headers once\r\n        const myHeaders = new Headers();\r\n        myHeaders.append(\"Content-Type\", \"application/json\");\r\n        // Step 1: Check if name exists\r\n        const checkResponse = await fetch(`${this.store.API_BASE}/check-name`, {\r\n          method: \"POST\",\r\n          headers: myHeaders,\r\n          body: raw,\r\n        });\r\n        if (!checkResponse.ok) {\r\n          return false;\r\n        }\r\n        const checkResult = await checkResponse.json();\r\n        // Example: only delete if API says name exists\r\n        if (checkResult.exists) {\r\n          const deleteResponse = await fetch(`${this.store.API_BASE}/delete-user`, {\r\n            method: \"POST\",\r\n            headers: myHeaders,\r\n            body: raw,\r\n          });\r\n          if (!deleteResponse.ok) {\r\n            return false;\r\n          }\r\n          const deleteResult = await deleteResponse.json();\r\n          return true;\r\n        } else {\r\n          return false;\r\n        }\r\n      } catch (error) {\r\n        return false;\r\n      }\r\n    },\r\n    async processImageData(data) {\r\n      let blob;\r\n      if (data.imageData instanceof Blob) {\r\n        // Case: camera emits Blob\r\n        blob = data.imageData;\r\n      }\r\n      else if (typeof data.imageData === \"string\" && data.imageData.startsWith(\"blob:\")) {\r\n        // Case: blob object URL\r\n        blob = await fetch(data.imageData).then(r => r.blob());\r\n      }\r\n      else if (typeof data.imageData === \"string\" && data.imageData.startsWith(\"data:image\")) {\r\n        // Case: Base64\r\n        blob = this.dataURLtoBlob(data.imageData);\r\n      }\r\n      else {\r\n        throw new Error(this.$t(\"UNSUPPORTED_IMAGE_DATA_FORMAT\"));\r\n      }\r\n      if (!blob) throw new Error(this.$t(\"ERROR_PROCESSING_IMAGE\"));\r\n      return blob;\r\n    },\r\n\r\n    dataURLtoBlob(dataURL) {\r\n      if (!dataURL || !dataURL.includes(\",\")) {\r\n\r\n        return null;\r\n      }\r\n\r\n      const [header, base64] = dataURL.split(',');\r\n      const match = header.match(/:(.*?);/);\r\n\r\n      if (!match) {\r\n\r\n        return null;\r\n      }\r\n\r\n      const mime = match[1];\r\n      const binary = atob(base64);\r\n      const len = binary.length;\r\n      const u8arr = new Uint8Array(len);\r\n\r\n      for (let i = 0; i < len; i++) {\r\n        u8arr[i] = binary.charCodeAt(i);\r\n      }\r\n\r\n      return new Blob([u8arr], { type: mime });\r\n    },\r\n\r\n\r\n\r\n    async detectAndCapture(data) {\r\n      // 1 Load face-api models & camera\r\n      const blob = await this.processImageData(data);\r\n      await this.uploadCapturedImages(blob);\r\n    },\r\n    handleCaptureError(error) {\r\n      const popupMessage = ` ${error.message || this.$t(\"ERROR_ACCESSING_CAMERA\")}`;\r\n      this.ShowAlert(popupMessage, \"failure\", true, this.$t(\"Alert\"));\r\n            this.handleClose();\r\n        },\r\n    async uploadCapturedImages(imageBlob) {\r\n      try {\r\n        this.isLoading = true;\r\n        //const imageURL = URL.createObjectURL(imageBlob);\r\n        //   const previewContainer = document.getElementById(\"face-preview\");\r\n\r\n        //   if (previewContainer) {\r\n        //     previewContainer.innerHTML = `\r\n        //   <div style=\"\r\n        //     display: flex; \r\n        //     flex-direction: column; \r\n        //     align-items: center; \r\n        //     justify-content: center;\r\n        //     padding: 10px;\r\n        //   \">\r\n        //     <img src=\"${imageURL}\" \r\n        //          alt=\"Captured Face\" \r\n        //          style=\"max-width: 250px; border-radius: 10px; box-shadow: 0 0 10px rgba(0,0,0,0.3);\" />\r\n        //     <p style=\"margin-top: 10px; font-size: 14px;\"> Captured Image Preview</p>\r\n        //   </div>\r\n        // `;\r\n        //   }\r\n\r\n        //  Optional: Check if user name exists first\r\n        await this.checkNameExists(this.id);\r\n        //  Prepare FormData\r\n        const formData = new FormData();\r\n        formData.append(\"id\", String(this.id || \"\")); // ensure always string\r\n        formData.append(\"name\", String(this.name || \"\"));\r\n        formData.append(\"companyId\", String(this.GetUserInfo?.CompanyId || \"\"));\r\n        formData.append(\"file\", new File([imageBlob], \"capture.jpg\", { type: \"image/jpeg\" }));\r\n\r\n\r\n        //  Send request to FastAPI\r\n        const response = await fetch(`${this.store.API_BASE}/upload`, {\r\n          method: \"POST\",\r\n          body: formData\r\n        });\r\n\r\n        const result = await response.json();\r\n        if (result.status === \"success\") {\r\n          //  Update user status\r\n          const updateRes = await DataService.UserListingfaceupdate({\r\n            status: 1,\r\n            userId: this.id\r\n          });\r\n          if (updateRes?.status === 200 || updateRes?.data?.status == \"Success\") {\r\n            //  If backend update succeeded, reflect in UI\r\n            this.$emit(\"statusUpdate\", { userId: this.id, status: 1 });\r\n            this.ShowAlert(this.$t('FACE_REGISTRATION_SUCCESS'), \"success\", true, this.$t(\"Alert\"));\r\n          } else {\r\n            const raw = JSON.stringify({\r\n              companyId: String(this.GetUserInfo.CompanyId),\r\n              id: String(this.id)\r\n            });\r\n            // Always define headers once\r\n            const myHeaders = new Headers();\r\n            myHeaders.append(\"Content-Type\", \"application/json\");\r\n            const deleteResponse = await fetch(`${this.store.API_BASE}/delete-user`, {\r\n              method: \"POST\",\r\n              headers: myHeaders,\r\n              body: raw,\r\n            });\r\n\r\n            if (!deleteResponse.ok) {\r\n              return false;\r\n            }\r\n\r\n            //this.ShowAlert(\" Face registered, but status update failed.\", \"warning\", true, this.$t(\"Alert\"));\r\n          }\r\n        } else {\r\n          this.ShowAlert(result.message || this.$t('FACE_REGISTRATION_FAILED'), \"failure\", true, this.$t(\"Alert\"));\r\n        }\r\n\r\n      } catch (err) {\r\n        this.ShowAlert(this.$t('UPLOAD_FAILED'), \"failure\", true, this.$t(\"Alert\"));\r\n      } finally {\r\n        this.isLoading = false;\r\n        this.handleClose();\r\n        if (this.$refs.faceCapture) this.$refs.faceCapture.resetCapture();\r\n      }\r\n    },\r\n\r\n\r\n    handleClose() {\r\n      this.store.resetCapture();\r\n      this.$emit(\"close\");\r\n    },\r\n\r\n  },\r\n\r\n  beforeDestroy() {\r\n\r\n  },\r\n};\r\n</script>\r\n\r\n<style scoped>\r\n.modal-dialog {\r\n  max-width: 612px !important;\r\n  padding: 0.5rem;\r\n}\r\n\r\n.videocontainer {\r\n  display: flex;\r\n  justify-content: center;\r\n  align-items: center;\r\n  padding: 1rem;\r\n}\r\n\r\nvideo {\r\n  width: 300px;\r\n  height: 300px;\r\n  border-radius: 50%;\r\n  object-fit: cover;\r\n  border: 3px solid #007bff;\r\n}\r\n\r\n.alertmessage {\r\n  text-align: center;\r\n  margin-top: 10px;\r\n  margin-bottom: 10px;\r\n  font-weight: bold;\r\n}\r\n\r\n.loader-overlay {\r\n  position: absolute;\r\n  top: 0;\r\n  left: 0;\r\n  width: 100%;\r\n  height: 100%;\r\n  display: flex;\r\n  flex-direction: column;\r\n  justify-content: center;\r\n  align-items: center;\r\n  background: rgba(255, 255, 255, 0.85);\r\n  border-radius: 10px;\r\n  z-index: 10;\r\n}\r\n\r\n.spinner {\r\n  border: 5px solid #f3f3f3;\r\n  border-top: 5px solid #007bff;\r\n  border-radius: 50%;\r\n  width: 50px;\r\n  height: 50px;\r\n  animation: spin 1s linear infinite;\r\n  margin-bottom: 10px;\r\n}\r\n\r\n@keyframes spin {\r\n  0% {\r\n    transform: rotate(0deg);\r\n  }\r\n\r\n  100% {\r\n    transform: rotate(360deg);\r\n  }\r\n}\r\n\r\n</style>\r\n","import mod from \"-!../../../node_modules/cache-loader/dist/cjs.js??ref--13-0!../../../node_modules/thread-loader/dist/cjs.js!../../../node_modules/babel-loader/lib/index.js!../../../node_modules/cache-loader/dist/cjs.js??ref--1-0!../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./FaceCapture.vue?vue&type=script&lang=js\"; export default mod; export * from \"-!../../../node_modules/cache-loader/dist/cjs.js??ref--13-0!../../../node_modules/thread-loader/dist/cjs.js!../../../node_modules/babel-loader/lib/index.js!../../../node_modules/cache-loader/dist/cjs.js??ref--1-0!../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./FaceCapture.vue?vue&type=script&lang=js\"","import { render, staticRenderFns } from \"./FaceCapture.vue?vue&type=template&id=4725214a&scoped=true\"\nimport script from \"./FaceCapture.vue?vue&type=script&lang=js\"\nexport * from \"./FaceCapture.vue?vue&type=script&lang=js\"\nimport style0 from \"./FaceCapture.vue?vue&type=style&index=0&id=4725214a&prod&scoped=true&lang=css\"\n\n\n/* normalize component */\nimport normalizer from \"!../../../node_modules/vue-loader/lib/runtime/componentNormalizer.js\"\nvar component = normalizer(\n  script,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  \"4725214a\",\n  null\n  \n)\n\nexport default component.exports","export * from \"-!../../../node_modules/vue-style-loader/index.js??ref--7-oneOf-1-0!../../../node_modules/@vue/cli-service/node_modules/css-loader/dist/cjs.js??ref--7-oneOf-1-1!../../../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../../node_modules/@vue/cli-service/node_modules/postcss-loader/src/index.js??ref--7-oneOf-1-2!../../../node_modules/@vue/cli-service/node_modules/postcss-loader/src/index.js??ref--7-oneOf-1-3!../../../node_modules/cache-loader/dist/cjs.js??ref--1-0!../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./FaceCapture.vue?vue&type=style&index=0&id=bc41805e&prod&scoped=true&lang=css\"","// Imports\nvar ___CSS_LOADER_API_IMPORT___ = require(\"../../../node_modules/@vue/cli-service/node_modules/css-loader/dist/runtime/api.js\");\nexports = ___CSS_LOADER_API_IMPORT___(false);\n// Module\nexports.push([module.id, \".modal-dialog[data-v-4725214a]{max-width:612px!important;padding:.5rem}.videocontainer[data-v-4725214a]{display:flex;justify-content:center;align-items:center;padding:1rem}video[data-v-4725214a]{width:300px;height:300px;border-radius:50%;-o-object-fit:cover;object-fit:cover;border:3px solid #007bff}.alertmessage[data-v-4725214a]{text-align:center;margin-top:10px;margin-bottom:10px;font-weight:700}.loader-overlay[data-v-4725214a]{position:absolute;top:0;left:0;width:100%;height:100%;display:flex;flex-direction:column;justify-content:center;align-items:center;background:hsla(0,0%,100%,.85);border-radius:10px;z-index:10}.spinner[data-v-4725214a]{border:5px solid #f3f3f3;border-top:5px solid #007bff;border-radius:50%;width:50px;height:50px;animation:spin-4725214a 1s linear infinite;margin-bottom:10px}@keyframes spin-4725214a{0%{transform:rotate(0deg)}to{transform:rotate(1turn)}}\", \"\"]);\n// Exports\nmodule.exports = exports;\n","// Imports\nvar ___CSS_LOADER_API_IMPORT___ = require(\"../../../node_modules/@vue/cli-service/node_modules/css-loader/dist/runtime/api.js\");\nexports = ___CSS_LOADER_API_IMPORT___(false);\n// Module\nexports.push([module.id, \".face-capture-container[data-v-bc41805e]{width:100%;max-width:600px;margin:0 auto}.video-container[data-v-bc41805e]{position:relative;width:100%;height:340px!important;padding-bottom:0;background:#fff;border-radius:0;overflow:hidden;border:2px solid hsla(0,0%,100%,.1);margin-bottom:20px;box-sizing:border-box}.video-container video[data-v-bc41805e]{-o-object-fit:contain!important;object-fit:contain!important;background:#000}.video-container canvas[data-v-bc41805e],.video-container video[data-v-bc41805e]{position:absolute;top:0;left:0;width:100%!important;height:100%!important;max-width:100%!important;max-height:100%!important;transform:scaleX(-1);box-sizing:border-box}.video-container canvas[data-v-bc41805e]{pointer-events:none;-o-object-fit:contain;object-fit:contain}.capture-flash[data-v-bc41805e]{position:absolute;top:0;left:0;width:100%;height:100%;background:hsla(0,0%,100%,.9);z-index:15;animation:flash-bc41805e .3s ease-out}@keyframes flash-bc41805e{0%{opacity:1}to{opacity:0}}.status-panel[data-v-bc41805e]{display:flex;flex-direction:column;gap:10px;margin-bottom:20px}.status-item[data-v-bc41805e]{display:flex;justify-content:space-between;align-items:center;padding:8px 12px;background:hsla(0,0%,100%,.05);border-radius:8px}.status-label[data-v-bc41805e]{flex:1;font-weight:500}.status-value[data-v-bc41805e]{font-weight:700}.status-good[data-v-bc41805e]{color:#27ae60}.status-warning[data-v-bc41805e]{color:#f39c12}.status-error[data-v-bc41805e]{color:#c0392b}.controls[data-v-bc41805e]{flex-direction:column;gap:15px}.controls[data-v-bc41805e],.stability-indicator[data-v-bc41805e]{display:flex;align-items:center}.stability-indicator[data-v-bc41805e]{gap:12px;margin-bottom:10px;padding:12px 20px;background:hsla(0,0%,100%,.1);border-radius:25px}.indicator-dot[data-v-bc41805e]{width:16px;height:16px;border-radius:50%;background-color:#c0392b;transition:all .3s ease}.indicator-dot.stable[data-v-bc41805e]{background-color:#27ae60;box-shadow:none}.indicator-dot.progress[data-v-bc41805e]{background-color:#f39c12;box-shadow:none}#captureBtn[data-v-bc41805e]{background:linear-gradient(135deg,#00b894,#00a085);color:#fff;border:none;padding:14px 30px;font-size:1.1rem;border-radius:50px;cursor:pointer;transition:all .3s ease;box-shadow:0 6px 20px rgba(0,184,148,.4);font-weight:700;width:100%;max-width:300px}#captureBtn[data-v-bc41805e]:hover:not(:disabled){transform:translateY(-3px);box-shadow:0 8px 25px rgba(0,184,148,.6)}#captureBtn[data-v-bc41805e]:disabled{background:linear-gradient(135deg,#636e72,#2d3436);cursor:not-allowed;transform:none;box-shadow:none}.processing-overlay[data-v-bc41805e]{position:absolute;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,.8);display:flex;flex-direction:column;align-items:center;justify-content:center;z-index:20;border-radius:12px;color:#fff}.processing-spinner[data-v-bc41805e]{border:4px solid hsla(0,0%,100%,.3);border-top:4px solid #0f8;border-radius:50%;width:50px;height:50px;animation:spin-bc41805e 1s linear infinite;margin-bottom:15px}.processing-overlay p[data-v-bc41805e]{font-size:1.1rem;font-weight:500}@keyframes spin-bc41805e{0%{transform:rotate(0deg)}to{transform:rotate(1turn)}}\", \"\"]);\n// Exports\nmodule.exports = exports;\n"],"sourceRoot":""}